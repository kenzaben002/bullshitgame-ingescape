.# > name="2 - Swagger C server"
.# > keyword="Swagger"
.# > description="Swagger in c"
.# > swaggerMode="ONE"
.# > agentMode="ZERO"

.template 0
if !defined(projects)
    abort "Error: can't find <projects> root tag, {file: $(gsl.filename)}."
endif

function isContentTypeString (contentType)
    if content.type <> "application/xml" & content.type <> "application/json" & content.type <> "text/css" & content.type <> "text/csv" & content.type <> "text/html" & content.type <> "text/plain" & content.type <> "text/xml"
        return 0
    endif
    return 1
endfunction isContentTypeString

function pathHasGET (path)
    for path.method as method
        if (method.type = "get")
            return 1
        endif
    endfor
    return 0
endfunction pathHasGET

function getHTTPType (type)
    if (type = "get")
        return "HTTP_GET"
    elsif (type = "post")
        return "HTTP_POST"
    elsif (type = "put")
        return "HTTP_PUT"
    elsif (type = "delete")
        return "HTTP_DELETE"
    endif
    return ""
endfunction

function hasMultipartFormDataFileContent (method)
    for method.body as body
        for body.content as content
            if content.type ?= "multipart/form-data"
                for content.schema as schema
                    if schema.type ?= "object"
                        for schema.property as property
                            for property.schema as p_schema
                                if p_schema.format ?= "binary"
                                    return 1
                                endif
                            endfor
                        endfor
                    endif
                endfor
            endif
        endfor
    endfor
    return 0
endfunction hasMultipartFormDataFileContent
.endtemplate
.template 1
.for projects. as project
.for project. as swaggers where name(swaggers) = "swaggers"
.
.####################################################################################
.echo "Creating directories structure ..."
.directory.create("builds/cmake")
.directory.create("dependencies")
.directory.create("packaging/windows")
.directory.create("packaging/unix")
.directory.create("src")
.
.####################################################################################
.echo "Generating builds/cmake/IdentifyOS.cmake ..."
.output "builds/cmake/IdentifyOS.cmake"
set(CMAKE_OS_NAME ${CMAKE_SYSTEM_NAME})
set(CMAKE_OS_VERSION ${CMAKE_SYSTEM_VERSION})

if (UNIX)
    if (APPLE)
        set (CMAKE_OS_NAME "OSX" CACHE STRING "Operating system name" FORCE)
        execute_process(COMMAND sw_vers -productVersion OUTPUT_VARIABLE CMAKE_OS_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE)
    else (APPLE)
        ## Check for Debian GNU/Linux _______________
        find_file (DEBIAN_FOUND debian_version debconf.conf PATHS /etc)
        if (DEBIAN_FOUND)
            set (CMAKE_OS_NAME "Debian" CACHE STRING "Operating system name" FORCE)
            file (STRINGS "/etc/debian_version" CMAKE_OS_VERSION)
            string (REGEX REPLACE "([0-9]+)(\\\\.[0-9]+)*" "\\\\1" CMAKE_OS_VERSION "${CMAKE_OS_VERSION}")

            ## Extra check for Ubuntu _______________
            find_file (UBUNTU_EXTRA legal issue PATHS /etc)
            if (UBUNTU_EXTRA)
                ## Scan contents of file
                file (STRINGS ${UBUNTU_EXTRA} UBUNTU_FOUND REGEX Ubuntu)
                ## Check result of string search
                if (UBUNTU_FOUND)
                    set (CMAKE_OS_NAME "Ubuntu" CACHE STRING "Operating system name" FORCE)
                    set (DEBIAN_FOUND FALSE)
                endif (UBUNTU_FOUND)
            endif (UBUNTU_EXTRA)
        endif (DEBIAN_FOUND)

        ## Check for Fedora _________________________
        find_file (FEDORA_FOUND fedora-release PATHS /etc)
        if (FEDORA_FOUND)
            set (CMAKE_OS_NAME "Fedora" CACHE STRING "Operating system name" FORCE)
        endif (FEDORA_FOUND)

        ## Check for RedHat _________________________
        find_file (REDHAT_FOUND redhat-release inittab.RH PATHS /etc)
        if (REDHAT_FOUND)
            set (CMAKE_OS_NAME "RedHat" CACHE STRING "Operating system name" FORCE)

            ## Extra check for CentOS _______________
            ## Scan contents of file
            file (STRINGS ${REDHAT_FOUND} CENTOS_FOUND REGEX "CentOS .* ([0-9]+)(\\.[0-9]+)*")
            ## Check result of string search
            if (CENTOS_FOUND)
                set (CMAKE_OS_NAME "CentOS" CACHE STRING "Operating system name" FORCE)
                string (REGEX REPLACE "CentOS .* ([0-9]+)(\\.[0-9]+)+.*" "\\1" CMAKE_OS_VERSION "${CENTOS_FOUND}")
                set (REDHAT_FOUND FALSE)
            endif (CENTOS_FOUND)
        endif (REDHAT_FOUND)
    endif (APPLE)
endif (UNIX)

message(STATUS "- OS Name     ${CMAKE_OS_NAME}")
message(STATUS "- OS Version  ${CMAKE_OS_VERSION}")

.
.for swaggers. as server
.####################################################################################
.echo "Generating src/$(server.name:Camel).h ..."
.output "src/$(server.name:Camel).h"
//
//  $(server.name:Camel).h
//  $(project.name:c)
//  Created by $(project.author:no)
//
//  $(project.copyright:no)
//

#ifndef $(server.name:Camel)_h
#define $(server.name:Camel)_h

#include <stdio.h>
#include <czmq.h>

.if count(server.url)
.for server.url as url
.if first()
#define $(server.name:c,UPPER)_DEFAULT_URL "$(url.url)"
.endif
.endfor
.else
#define $(server.name:c,UPPER)_DEFAULT_URL "http://localhost:8080"
.endif

extern char *s_$(server.name:Camel)_certPath;
extern char *s_$(server.name:Camel)_privateKeyPath;

void $(server.name:Camel)_initActor(zsock_t *pipe, void *args);
void $(server.name:Camel)_destroyActor(zactor_t **actor);

#endif /* $(server.name:Camel)_h */
.
.####################################################################################
.echo "Generating src/$(server.name:Camel).c ..."
.output "src/$(server.name:Camel).c"
//
//  $(server.name:Camel).c
//  $(project.name:c)
//  Created by $(project.author:no)
//
//  $(project.copyright:no)
//

#include "$(server.name:Camel).h"
#include <ingescape/ingescape.h>
#include <libwebsockets.h>
#include <stdbool.h>

char *s_$(server.name:Camel)_certPath = NULL;
char *s_$(server.name:Camel)_privateKeyPath = NULL;
bool $(server.name:Camel)_interrupted = false;
struct lws_context *$(server.name:Camel)_context = NULL;

typedef enum {
    HTTP_GET = 0,
    HTTP_POST,
    HTTP_PUT,
    HTTP_DELETE,
    HTTP_UNKNOWN
} query_type_t;

//libwebsocket per connection data
typedef struct per_connection_data {
    struct lws *wsi;
    char *endpoint;
    query_type_t type;
    zchunk_t* requestBody;
    unsigned int responseStatus;
    const char *responseContentType;
    char *responseBody;
} per_connection_data_t;

///////////////////////////////////////////////////////////////////////////////
// LWS internal functions and callbacks
//
void $(server.name:Camel)_closeHTTPRequest(per_connection_data_t *perConnectionData, unsigned int code){
    assert(perConnectionData);
    perConnectionData->responseStatus = code;
    lws_callback_on_writable(perConnectionData->wsi); // Response will be sent in LWS_CALLBACK_HTTP_WRITEABLE protocol callback
}

.for server.path as path
// $(path.name)
.for path.method as method
.if hasMultipartFormDataFileContent(path)
typedef struct $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_files_parser {
.for method.body as body
.for body.content as content
.if content.type ?= "multipart/form-data"
.for content.schema as schema
.if schema.type ?= "object"
.for schema.property as property
.for property.schema as p_schema
.if p_schema.format ?= "binary"
    zchunk_t* $(property.name:c)Content;
.endif
.endfor
.endfor
.endif
.endfor
.endif
.endfor
.endfor
} $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_files_parser_t;

static int $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_parseFile(void *data, const char *name, const char *filename, char *buf, int len, enum lws_spa_fileupload_states state)
{
    $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_files_parser_t *filesParser =  ($(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_files_parser_t *)data;
	switch (state) {
        case LWS_UFS_FINAL_CONTENT:
        case LWS_UFS_CONTENT:
.cpt = 0
.for method.body as body
.for body.content as content
.if content.type ?= "multipart/form-data"
.for content.schema as schema
.if schema.type ?= "object"
.for schema.property as property
.for property.schema as p_schema
.if p_schema.format ?= "binary"
.if cpt ?=0
            if (streq(name, "$(property.name:no)"))
.else
            else if (streq(name, "$(property.name:no)"))
.endif
                zchunk_extend(filesParser->$(property.name:c)Content, buf, len);
.cpt = cpt + 1
.endif
.endfor
.endfor
.endif
.endfor
.endif
.endfor
.endfor
            break;
        default:
            break;
    }
	return 0;
}

.endif
void $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)(per_connection_data_t *perConnectionData){
.
.for method.query_parameter as queryParam
    char query_$(queryParam.name:Camel)[LWS_RECOMMENDED_MIN_HEADER_SPACE];
.for queryParam.schema
.if schema.type ?= "number"
    double query_$(queryParam.name:Camel)Value;
.elsif schema.type ?= "integer"
    int query_$(queryParam.name:Camel)Value;
.elsif schema.type ?= "boolean"
    bool query_$(queryParam.name:Camel)Value = false;
.endif
.endfor
.
.if queryParam.required ?= "true"
    if (lws_get_urlarg_by_name(perConnectionData->wsi, "$(queryParam.name:no)", query_$(queryParam.name:Camel), sizeof(query_$(queryParam.name:Camel))) == NULL){
        perConnectionData->responseContentType = "text/plain";
        perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' query parameter (string expected)");
        $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
        return;
    }
.
.if count(queryParam.schema) ?= 1
.for queryParam.schema
.if schema.type ?= "number"
    if (sscanf(query_$(queryParam.name:Camel), "%lf", &query_$(queryParam.name:Camel)Value) == -1) {
        perConnectionData->responseContentType = "text/plain";
        perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' argument (double expected)");
        $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
        return;
    }
.elsif schema.type ?= "integer"
    if (sscanf(query_$(queryParam.name:Camel), "%d", &query_$(queryParam.name:Camel)Value) == -1) {
        perConnectionData->responseContentType = "text/plain";
        perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' argument (integer expected)");
        $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
        return;
    }
.elsif schema.type ?= "boolean"
    if (streq(query_$(queryParam.name:Camel), "true"))
        query_$(queryParam.name:Camel)Value = true;
    else if (!streq(query_$(queryParam.name:Camel), "false")) {
        perConnectionData->responseContentType = "text/plain";
        perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' argument ('true' or 'false' expected)");
        $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
        return;
    }
.endif
.endfor
.else
    // FIXME: handle multiple values of query_$(queryParam.name:Camel)
.endif
.
.else
    if (lws_get_urlarg_by_name(perConnectionData->wsi, "$(queryParam.name:no)", query_$(queryParam.name:Camel), sizeof(query_$(queryParam.name:Camel))) != NULL){
.if count(queryParam.schema) ?= 1
.for queryParam.schema
.if schema.type ?= "number"
        if (sscanf(query_$(queryParam.name:Camel), "%lf", &query_$(queryParam.name:Camel)Value) == -1){
            perConnectionData->responseContentType = "text/plain";
            perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' argument (double expected)");
            $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
            return;
        }
.elsif schema.type ?= "integer"
        if (sscanf(query_$(queryParam.name:Camel), "%d", &query_$(queryParam.name:Camel)Value) == -1){
            perConnectionData->responseContentType = "text/plain";
            perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' argument (integer expected)");
            $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
            return;
        }
.elsif schema.type ?= "boolean"
        if (streq(query_$(queryParam.name:Camel), "true"))
            query_$(queryParam.name:Camel)Value = true;
        else if (!streq(query_$(queryParam.name:Camel), "false")){
            perConnectionData->responseContentType = "text/plain";
            perConnectionData->responseBody = strdup("URL does not contain a valid '$(queryParam.name:no)' argument ('true' or 'false' expected)");
            $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
            return;
        }
.endif
.endfor
.else
        // FIXME: handle multiple values of query_$(queryParam.name:Camel)
.endif
    }
.endif
.endfor
    igs_info("Receive $(method.type:UPPER) $(path.endpoint:no) (\
.if count(method.query_parameter)
.for method.query_parameter as queryParam
.for queryParam.schema as schema
$(queryParam.name:no):%s\
.endfor
.
.if !last()
, \
.endif
.endfor
.
.else
no query parameters\
.endif
)" \
.for method.query_parameter as queryParam
, query_$(queryParam.name:Camel)\
.endfor
);
.
.for method.header_parameter as headerParam

    char header_$(headerParam.name:Camel)[LWS_RECOMMENDED_MIN_HEADER_SPACE];
    lws_hdr_custom_copy(perConnectionData->wsi, header_$(headerParam.name:Camel), sizeof(header_$(headerParam.name:Camel)), "$(headerParam.name):", strlen("$(headerParam.name):"));
    igs_info("  with header $(headerParam.name): %s", header_$(headerParam.name:Camel));
.endfor
.
.if count(method.body)
    int contentTypeLength = lws_hdr_total_length(perConnectionData->wsi, WSI_TOKEN_HTTP_CONTENT_TYPE);
    char *contentType = calloc(1, contentTypeLength + 1);
    lws_hdr_copy(perConnectionData->wsi, contentType, contentTypeLength + 1, WSI_TOKEN_HTTP_CONTENT_TYPE);
.for method.body as body
.if count(body.content)
.for body.content as content
.if !first()
else if (strncmp("$(content.type)", contentType, strlen("$(content.type)")) == 0){
.else
    if (strncmp("$(content.type)", contentType, strlen("$(content.type)")) == 0){
.endif
.
.if content.type ?= "multipart/form-data"
        const char * const param_names[] = {
.for content.schema as schema
.if schema.type ?= "object"
.for schema.property as property
            "$(property.name:no)",
.endfor
.endif
.endfor
        };

.if hasMultipartFormDataFileContent(method)
        $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_files_parser_t * filesParser = calloc(1, sizeof($(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_files_parser_t));
.for content.schema as schema
.if schema.type ?= "object"
.for schema.property as property
.for property.schema as p_schema
.if p_schema.format ?= "binary"
        filesParser->$(property.name:c)Content = zchunk_new(NULL, 0);
.endif
.endfor
.endfor
.endif
.endfor
        struct lws_spa *postArgsParser = lws_spa_create(perConnectionData->wsi, param_names, LWS_ARRAY_SIZE(param_names), 1024, $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)_parseFile, filesParser);
.else
        struct lws_spa *postArgsParser = lws_spa_create(perConnectionData->wsi, param_names, LWS_ARRAY_SIZE(param_names), 1024, NULL, NULL);
.endif
        assert(postArgsParser);
        lws_spa_process(postArgsParser, (char *) zchunk_data(perConnectionData->requestBody), zchunk_size(perConnectionData->requestBody));
        lws_spa_finalize(postArgsParser);

        igs_info("  with body post arguments :");
.cpt = 0
		for (int n = 0; n < (int)LWS_ARRAY_SIZE(param_names); n++) {
.for content.schema as schema
.if schema.type ?= "object"
.for schema.property as property
.for property.schema as p_schema
.if p_schema.format ?= "binary"
.if cpt ?= 0
            if (streq(param_names[n], "$(property.name:no)"))
.else
            else if (streq(param_names[n], "$(property.name:no)"))
.endif
                igs_info("      %s: (data len %zu))", param_names[n], zchunk_size(filesParser->$(property.name:c)Content));
.cpt = cpt + 1
.endif
.endfor
.endfor
.endif
.endfor
.if cpt ?= 0
			if (!lws_spa_get_string(postArgsParser, n))
.else
            else if (!lws_spa_get_string(postArgsParser, n))
.endif
				igs_info("      %s: undefined", param_names[n]);
			else
				igs_info("      %s: (len %d) '%s'", param_names[n], lws_spa_get_length(postArgsParser, n), lws_spa_get_string(postArgsParser, n));
		}

        // Add code here if needed

.if hasMultipartFormDataFileContent(method)
.for content.schema as schema
.if schema.type ?= "object"
.for schema.property as property
.for property.schema as p_schema
.if p_schema.format ?= "binary"
        zchunk_destroy(&filesParser->$(property.name:c)Content);
.endif
.endfor
.endfor
.endif
.endfor
        free(filesParser);
.endif
		lws_spa_destroy(postArgsParser);
.elsif content.type ?= "application/json"
        igs_json_node_t *body = igs_json_node_parse_from_str((char *) zchunk_data(perConnectionData->requestBody));
        if (body == NULL){
            perConnectionData->responseContentType = "text/plain";
            perConnectionData->responseBody = strdup("Invalid json body");
            $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_BAD_REQUEST);
            return;
        }
        igs_info("  with body %s", (char *) zchunk_data(perConnectionData->requestBody));
        // Add code here if needed
        igs_json_node_destroy(&body);
.elsif isContentTypeString(content.type)
        char *body = (char *) zchunk_data(perConnectionData->requestBody);
        igs_info("  with body %s", (char *) zchunk_data(perConnectionData->requestBody));
        // Add code here if needed
.else
        void *body = zchunk_data(perConnectionData->requestBody);
        igs_info("  with body size %zu", zchunk_size(perConnectionData->requestBody));
        // Add code here if needed
.endif
.
    }\
.endfor
else{
        $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE);
        zstr_free(&contentType);
        return;
    }
    zstr_free(&contentType);
.endif
.endfor

.endif

    perConnectionData->responseContentType = "text/plain";
    perConnectionData->responseBody = strdup("Behavior not implemented");
    $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_OK);
}

.endfor
.endfor
.
static int
$(server.name:Camel)_protocol(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len){
    per_connection_data_t *perConnectionData = (per_connection_data_t *)user;
    switch (reason) {
        case LWS_CALLBACK_HTTP_CONFIRM_UPGRADE: {
            igs_debug("[LWS_CALLBACK_HTTP_CONFIRM_UPGRADE] Confirm upgrade to %s", (char *) in);
            return -1; // -1 close HTTP connection
        }
        case LWS_CALLBACK_HTTP: {
            igs_debug("[LWS_CALLBACK_HTTP] HTTP Request");
            if (!perConnectionData){
                igs_error("Per connection data are not initialized");
                return -1;
                // -1 close HTTP connection
            }

            perConnectionData->wsi = wsi;
            perConnectionData->endpoint = strdup((char *) in);
            perConnectionData->requestBody = zchunk_new(NULL, 0);
            perConnectionData->responseStatus = HTTP_STATUS_INTERNAL_SERVER_ERROR;
            perConnectionData->responseContentType = NULL;
            perConnectionData->responseBody = NULL;

            perConnectionData->type = HTTP_UNKNOWN;
            if (lws_hdr_total_length(wsi, WSI_TOKEN_GET_URI))
                perConnectionData->type = HTTP_GET;
            else if (lws_hdr_total_length(wsi, WSI_TOKEN_POST_URI))
                perConnectionData->type = HTTP_POST;
            else if (lws_hdr_total_length(wsi, WSI_TOKEN_PUT_URI))
                perConnectionData->type = HTTP_PUT;
            else if (lws_hdr_total_length(wsi, WSI_TOKEN_DELETE_URI))
                perConnectionData->type = HTTP_DELETE;

.if count(server.path)
.for server.path as path
.if first()
            if (streq(perConnectionData->endpoint, "$(path.endpoint)")){
.else
 else if (streq(perConnectionData->endpoint, "$(path.endpoint)")){
.endif
.if count(path.method)
                if \
.if count(path.method) ?> 1
(\
.endif
.for path.method as method
(perConnectionData->type != \
$(getHTTPType(method.type))\
)\
.if !last()
 && \
.endif
.endfor
.if count(path.method) ?>1
)\
.endif
{
                    $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_METHOD_NOT_ALLOWED);
                    return 0;
                }
.endif
.
.
.if pathHasGET(path)
                if (perConnectionData->type == HTTP_GET)
                    $(server.name:Camel)_$(path.name:no)GET(perConnectionData);
.if count(path.method) ?> 1
                //else: action will be executed when request body is received
.endif
.else
.if count(path.method) ?> 1
                //action will be executed when request body is received
.endif
.endif
            }\
.endfor
 else
                $(server.name:Camel)_closeHTTPRequest(perConnectionData, HTTP_STATUS_NOT_FOUND);
.endif
            break;
        }
        case LWS_CALLBACK_HTTP_BODY: {
            igs_debug("[LWS_CALLBACK_HTTP_BODY] HTTP Request body");
            if (!perConnectionData){
                igs_error("Per connection data are not initialized");
                return -1; // -1 close HTTP connection
            }
            // Save fragments to reconstruct it on LWS_CALLBACK_HTTP_BODY_COMPLETION
            if (in)
                zchunk_extend(perConnectionData->requestBody, in, len);
            break;
        }
        case LWS_CALLBACK_HTTP_BODY_COMPLETION: {
            igs_debug("[LWS_CALLBACK_HTTP_BODY_COMPLETION] HTTP Request body complete");
            if (!perConnectionData){
                igs_error("Per connection data are not initialized");
                return -1; // -1 close HTTP connection
            }

            // No more payload data coming
            if (zchunk_size(perConnectionData->requestBody) > 0)
                zchunk_extend(perConnectionData->requestBody, in, len);

.for server.path as path
.cpt = 0
.if ((pathHasGET(path) & count(path.method) > 1) | (!pathHasGET(path) & count(path.method)))
.if cpt ?= 0
            if (streq(perConnectionData->endpoint, "$(path.endpoint)"))
.else
            else if (streq(perConnectionData->endpoint, "$(path.endpoint)"))
.endif
.for path.method as method
.if method.type ?<> "get"
                if (perConnectionData->type == $(getHTTPType(method.type)))
                    $(server.name:Camel)_$(path.name:no)$(method.type:UPPER)(perConnectionData);
.endif
.cpt = cpt + 1
.endfor
.endif
.endfor
            break;
        }
        case LWS_CALLBACK_HTTP_WRITEABLE: {
            igs_debug("[LWS_CALLBACK_HTTP_WRITEABLE] HTTP Request writable, send response");
            uint8_t buf[LWS_PRE + LWS_RECOMMENDED_MIN_HEADER_SPACE],
                *start = &buf[LWS_PRE], *p = start,
                *end = p + sizeof(buf) - LWS_PRE;

            if (!perConnectionData){
                igs_error("Per connection data are not initialized");
                return -1; // -1 close HTTP connection
            }

            // Headers
            if (lws_add_http_common_headers(wsi, perConnectionData->responseStatus,
                                            perConnectionData->responseContentType,
                                            LWS_ILLEGAL_HTTP_CONTENT_LEN, //no content len
                                            &p, end))
                return -1; // -1 close HTTP connection
            if (lws_finalize_write_http_header(wsi, start, &p, end))
                return -1; // -1 close HTTP connection

            // Content
            if (perConnectionData->responseBody){
                unsigned long contentLength = strlen(perConnectionData->responseBody);
                lws_write(wsi, (unsigned char*) perConnectionData->responseBody, contentLength, LWS_WRITE_HTTP);
            }

            if (perConnectionData->responseStatus == HTTP_STATUS_OK)
                igs_info("Request on %s endpoint succeeded, response status = 200", perConnectionData->endpoint);
            else
                igs_info("Request on %s endpoint failed, response status = %d",  perConnectionData->endpoint, perConnectionData->responseStatus);

            if (lws_http_transaction_completed(wsi))
                return -1; // -1 close HTTP connection
            break;
        }
        case LWS_CALLBACK_CLOSED_HTTP: {
            igs_debug("[LWS_CALLBACK_CLOSED_HTTP] HTTP Request closed");
            if (perConnectionData) {
                if (perConnectionData->endpoint)
                    zstr_free(&perConnectionData->endpoint);
                if (perConnectionData->requestBody){
                    zchunk_destroy(&(perConnectionData->requestBody));
                    perConnectionData->requestBody = NULL;
                }
                if (perConnectionData->responseBody)
                    zstr_free(&perConnectionData->responseBody);
            }
            break;
        }
        default:
            igs_debug("Unhandled reason %d", reason);
            break;
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////
// INITIALIZER & DESTRUCTOR
//
static struct lws_protocols protocols[] = {
    { "$(server.name:Camel)", $(server.name:Camel)_protocol, sizeof(per_connection_data_t), 0, 0, NULL, 0 },
    { NULL, NULL, 0, 0 } // terminator
};

void $(server.name:Camel)_logEmit(int level, const char *line){
    //lws logs to igs logs
    char * log = strdup(line);
    if (log[strlen(log) - 1] == '\\n')
        log[strlen(log) - 1] = '\\0';
    if (level == LLL_ERR)
        igs_error("[LWS] %s", log);
    else if (level == LLL_WARN)
        igs_warn("[LWS] %s", log);
    else
        igs_debug("[LWS] (log level : %d) : %s", level, log);
    free(log);
}

void $(server.name:Camel)_initActor(zsock_t *pipe, void *args){
    char *httpEndpoint = (char *)args;
    char httpProtocol[5], httpHost[250];
    int httpPort;

    int logs = LLL_USER | LLL_ERR | LLL_WARN | LLL_HEADER | LLL_EXT | LLL_CLIENT | LLL_LATENCY | LLL_NOTICE | LLL_DEBUG | LLL_INFO | LLL_PARSER ;
    lws_set_log_level(logs, $(server.name:Camel)_logEmit);

    struct lws_context_creation_info info;

    //get protocol/host/port from endpoint
    char * httpEndpointWithSpace = (char *)malloc(strlen(httpEndpoint) + 1);
    for (int i = 0; i < strlen(httpEndpoint); i++){
        if (httpEndpoint[i] == ':')
            httpEndpointWithSpace[i] = ' ';
        else
            httpEndpointWithSpace[i] = httpEndpoint[i];
    }
    httpEndpointWithSpace[strlen(httpEndpoint)] = '\\0';
    sscanf(httpEndpointWithSpace, "%s //%s %d", httpProtocol, httpHost, &httpPort);
    free(httpEndpointWithSpace);

    //server creation
    memset(&info, 0, sizeof(info));
    info.port = httpPort;
    info.vhost_name = httpHost;
    info.protocols = protocols;
    info.options =
        LWS_SERVER_OPTION_HTTP_HEADERS_SECURITY_BEST_PRACTICES_ENFORCE;

    //security
    if (s_$(server.name:Camel)_certPath
        && strlen(s_$(server.name:Camel)_certPath)
        && s_$(server.name:Camel)_privateKeyPath
        && strlen(s_$(server.name:Camel)_privateKeyPath)){
#if defined(LWS_WITH_TLS)
        igs_info("$(server.name:Camel) server use SSL");
        info.options |= LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
        info.ssl_cert_filepath = s_$(server.name:Camel)_certPath;
        info.ssl_private_key_filepath = s_$(server.name:Camel)_privateKeyPath;
#else
        igs_fatal("Could not create $(server.name:Camel) ssl server : libwebsocket must be build with openssl, our agent will STOP");
        zstr_send(pipe, "STOPPED");
        return;
#endif
    }

    $(server.name:Camel)_context = lws_create_context(&info);
    if (!$(server.name:Camel)_context){
        igs_fatal("Could not create $(server.name:Camel) server on %s : our agent will STOP", httpEndpoint);
        zstr_send(pipe, "STOPPED");
        return;
    }

    igs_info("$(server.name:Camel) proxy started at %s", httpEndpoint);
    int n = 0;
    bool terminated = false;
    zsock_signal(pipe, 0);
    while (!terminated){
        while ((n >= 0) && !$(server.name:Camel)_interrupted)
            n = lws_service($(server.name:Camel)_context, 0);

        zmsg_t *msg = zmsg_recv (pipe);
        if (msg){
            char *command = zmsg_popstr (msg);
            if (streq (command, "$TERM")){
                terminated = true;
                break;
            }
            //else: invalid command
            freen(command);
            zmsg_destroy(&msg);
        }
    }

    igs_info("$(server.name:Camel) proxy stopping...");
    lws_context_destroy($(server.name:Camel)_context);
    igs_info("$(server.name:Camel) proxy stopped.");
}

void $(server.name:Camel)_destroyActor(zactor_t **actor){
    assert($(server.name:Camel)_context);
    $(server.name:Camel)_interrupted = true;;
    lws_cancel_service($(server.name:Camel)_context); //to properly stop the lws loop
    zactor_destroy(actor);
}

.
.endfor
.####################################################################################
.echo "Generating src/main.c ..."
.output "src/main.c"
//
//  main.c
//  $(project.name:c)
//  Created by $(project.author:no)
//
//  $(project.copyright:no)
//

#if defined(__unix__) || defined(__linux__) || (defined(__APPLE__) && defined(__MACH__))
    #include <pthread.h>
#elif (defined WIN32 || defined _WIN32)
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #define NOMINMAX
    #include <windows.h>
    #include <winsock2.h>
#endif

#include <ingescape/ingescape.h>
#include <getopt.h>
.for swaggers. as server
#include "$(server.name:Camel).h"
.endfor

//default agent parameters to be overriden by command line parameters
#define PORT 5670
#define AGENT_NAME "$(project.name:Camel)"
#define DEVICE NULL
#define IS_VERBOSE false
#define DEFAULT_REQUEST_TIMEOUT 10

int ingescapeSentMessage(zloop_t *loop, zsock_t *reader, void *arg){
    char *message = NULL;
    zsock_recv(reader, "s", &message);
    if (streq(message, "LOOP_STOPPED")){
        igs_info("LOOP_STOPPED received from Ingescape");
        return -1;
    }else
        return 0;
}

int actorSentMessage(zloop_t *loop, zsock_t *reader, void *arg){
    char *name = (char *)arg;
    char *message = NULL;
    zsock_recv(reader, "s", &message);
    if (streq(message, "STOPPED")){
        igs_info("STOPPED received in main app from %s thread", name);
        return -1;
    }else
        return 0;
}

///////////////////////////////////////////////////////////////////////////////
// COMMAND LINE AND INTERPRETER OPTIONS
//
void print_usage(void){
    printf("Usage examples:\\n");
    printf("    ./$(project.name:no) --verbose --device en0 --port 5670\\n");
    printf("\\nIngescape parameters:\\n");
    printf("--verbose : enable verbose mode in the application (default is disabled)\\n");
    printf("--device device_name : name of the network device to be used (useful if several devices are available)\\n");
    printf("--port port_number : port used for autodiscovery between agents (default: %d)\\n", PORT);
    printf("--name agent_name : published name of this agent (default: %s)\\n", AGENT_NAME);
    printf("--interactiveloop : enables interactive loop to pass commands in CLI (default: false)\\n");
    printf("Security:\\n");
    printf("--igsCert filePath : path to a private certificate used to connect to a secure platform\\n");
    printf("--publicCerts directoryPath : path to a directory providing public certificates usable by ingescape\\n");
    printf("\\nHTTP parameters:\\n");
.for swaggers. as server
    printf("--$(server.name:Camel)Url : $(server.name:Camel) server url we can be reached at (default: %s)\\n", $(server.name:c,UPPER)_DEFAULT_URL);
    printf("--$(server.name:Camel)Cert filePath : path to the certificate for the $(server.name:Camel) server\\n");
    printf("--$(server.name:Camel)PrivateKey filePath : path to the private key for the $(server.name:Camel) server\\n");
.endfor
    printf("\\n");
}

//resolve paths starting with ~ to absolute paths
void resolveUserPathIn(char path[], size_t maxSize) {
    if (path && strlen(path) && path[0] == '~') {
        char *temp = strdup(path+1);
#ifdef _WIN32
        char *home = getenv("USERPROFILE");
#else
        char *home = getenv("HOME");
#endif
        if (!home)
            igs_error("could not find path for home directory");
        else{
            strncpy(path, home, maxSize);
            strncat(path, temp, maxSize);
        }
        free(temp);
    }
}

void print_cli_usage(void) {
    printf("Available commands in the terminal:\\n");
    printf("\t/quit : quits the agent\\n");
    printf("\t/help : displays this message\\n");
}

///////////////////////////////////////////////////////////////////////////////
// MAIN
//
int main(int argc, const char * argv[]) {
    int opt = 0;
    bool verbose = IS_VERBOSE;
    char *networkDevice = DEVICE;
    unsigned int port = PORT;
    char *agentName = AGENT_NAME;
    bool interactiveloop = false;
    char igsCertPath[IGS_MAX_PATH_LENGTH] = "";
    char publicCertsDir[IGS_MAX_PATH_LENGTH] = "";
.for swaggers. as server
    zactor_t *$(server.name:camel)Actor = NULL;
    char *$(server.name:camel)Url = $(server.name:c,UPPER)_DEFAULT_URL;
    char $(server.name:camel)CertPath[IGS_MAX_PATH_LENGTH] = "";
    char $(server.name:camel)PrivateKeyPath[IGS_MAX_PATH_LENGTH] = "";
.endfor

    static struct option long_options[] = {
        {"verbose", no_argument, 0,  'v' },
        {"device", required_argument, 0,  'd' },
        {"port", required_argument, 0,  'p' },
        {"name", required_argument, 0,  'n' },
        {"interactiveloop", no_argument, 0,  'i' },
        {"help", no_argument, 0,  'h' },
        {"igsCert", required_argument, 0,  'c' },
        {"publicCerts", required_argument, 0,  's' },
.cpt = 0
.for swaggers. as server
        {"$(server.name:camel)Url", required_argument, 0,  '$(cpt)' },
.cpt = cpt + 1
        {"$(server.name:camel)Cert", required_argument, 0,  '$(cpt)' },
.cpt = cpt + 1
        {"$(server.name:camel)PrivateKey", required_argument, 0,  '$(cpt)' },
.cpt = cpt + 1
.endfor
        {0, 0, 0, 0}
    };

    int long_index = 0;
    while ((opt = getopt_long(argc, (char *const *)argv, "p", long_options, &long_index)) != -1) {
        switch (opt) {
            case 'v':
                verbose = true;
                break;
            case 'd':
                networkDevice = optarg;
                break;
            case 'p':
                port = (unsigned int)atoi(optarg);
                break;
            case 'n':
                agentName = optarg;
                break;
            case 'i':
                interactiveloop = true;
                break;
            case 'h':
                print_usage();
                exit(IGS_SUCCESS);
            case 'c':
                strncpy(igsCertPath, optarg, IGS_MAX_PATH_LENGTH);
                break;
            case 's':
                strncpy(publicCertsDir, optarg, IGS_MAX_PATH_LENGTH);
                break;
.cpt = 0
.for swaggers. as server
            case '$(cpt)':
                $(server.name:camel)Url = optarg;
                break;
.cpt = cpt + 1
            case '$(cpt)':
                strncpy($(server.name:camel)CertPath, optarg, IGS_MAX_PATH_LENGTH);
                break;
.cpt = cpt + 1
            case '$(cpt)':
                strncpy($(server.name:camel)PrivateKeyPath, optarg, IGS_MAX_PATH_LENGTH);
                break;
.cpt = cpt + 1
.endfor
            default:
//                print_usage();
//                exit(IGS_FAILURE);
                break;
        }
    }

    igs_agent_set_name(agentName);
    igs_log_set_console(verbose);
    igs_log_set_file(true, NULL);
    igs_log_set_stream(verbose);
    igs_definition_set_version("1.0");
    igs_set_command_line_from_args(argc, argv);

    //security
    resolveUserPathIn(igsCertPath, IGS_MAX_PATH_LENGTH);
    if (strlen(igsCertPath) && zfile_exists(igsCertPath))
        assert(igs_enable_security(igsCertPath, publicCertsDir) == IGS_SUCCESS);
    else if (strlen(igsCertPath)){
        igs_error("Could not find Ingescape certificate file '%s': exiting", igsCertPath);
        exit(IGS_FAILURE);
    }
.for swaggers. as server
    if (strlen($(server.name:camel)CertPath)){
        if (zfile_exists($(server.name:camel)CertPath)){
            s_$(server.name:Camel)_certPath= $(server.name:camel)CertPath;
            if (zfile_exists($(server.name:camel)PrivateKeyPath)){
                s_$(server.name:Camel)_privateKeyPath = $(server.name:camel)PrivateKeyPath;
            }else{
                igs_error("$(server.name:Camel) server private key file '%s' does not exist: exiting", $(server.name:camel)PrivateKeyPath);
                exit(IGS_FAILURE);
            }
        }else{
            igs_error("$(server.name:Camel) server certificate file '%s' does not exist: exiting", $(server.name:camel)CertPath);
            exit(IGS_FAILURE);
        }
    }
.endfor

    if (networkDevice == NULL){
        //we have no device to start with: try to find one
        int nbD = 0;
        int nbA = 0;
        char **devices = igs_net_devices_list(&nbD);
        char **addresses = igs_net_addresses_list(&nbA);
        assert(nbD == nbA);
        if (nbD == 1){
            //we have exactly one compliant network device available: we use it
            networkDevice = strdup(devices[0]);
            igs_info("using %s as default network device (this is the only one available)", networkDevice);
        }else if (nbD == 2 && (strcmp(addresses[0], "127.0.0.1") == 0 || strcmp(addresses[1], "127.0.0.1") == 0)){
            //we have two devices, one of which is the loopback
            //pick the device that is NOT the loopback
            if (strcmp(addresses[0], "127.0.0.1") == 0){
                networkDevice = strdup(devices[1]);
            }else{
                networkDevice = strdup(devices[0]);
            }
            igs_info("using %s as default network device (this is the only one available that is not the loopback)", networkDevice);
        }else{
            if (nbD == 0){
                igs_error("No network device found: aborting.");
            }else{
                igs_error("No network device passed as command line parameter and several are available.");
                printf("Please use one of these network devices:\\n");
                for (int i = 0; i < nbD; i++){
                    printf("\t%s\\n", devices[i]);
                }
                printf("\\n");
                print_usage();
            }
            exit(1);
        }
        igs_free_net_devices_list(devices, nbD);
        igs_free_net_addresses_list(addresses, nbD);
    }

    //initialize servers
.for swaggers. as server
    if ($(server.name:camel)Url && strlen($(server.name:camel)Url)){
        $(server.name:camel)Actor = zactor_new($(server.name:camel)_initActor, $(server.name:camel)Url);
        assert($(server.name:camel)Actor);
    }
.endfor

    //actually start ingescape
    igs_start_with_device(networkDevice, port);

    //mainloop management (two modes)
    if (!interactiveloop) {
        //Run the main loop (non-interactive mode):
        //we rely on CZMQ which is an ingescape dependency
        //and is thus always available.
        zloop_t *loop = zloop_new();
        zsock_t *pipe = igs_pipe_to_ingescape();
        if (pipe)
            zloop_reader(loop, pipe, ingescapeSentMessage, NULL);
        zloop_start(loop);
        zloop_destroy(&loop);
    }else{
        char message[IGS_MAX_LOG_LENGTH];
        char command[IGS_MAX_LOG_LENGTH];
        char param1[IGS_MAX_LOG_LENGTH];
        char param2[IGS_MAX_LOG_LENGTH];
        int usedChar = 0;
        print_cli_usage();
        while (igs_is_started()) {
            if (!fgets(message, IGS_MAX_LOG_LENGTH, stdin))
                break;
            if ((message[0] == '/') && (strlen(message) > 2)) {
                int matches = sscanf(message + 1, "%s %s%n%s", command, param1, &usedChar, param2);
                if (matches > 2) {
                    // copy the remaining of the message in param 2
                    strncpy(param2, message + usedChar + 2, IGS_MAX_LOG_LENGTH);
                    // remove '\\n' at the end
                    param2[strnlen(param2, IGS_MAX_LOG_LENGTH) - 1] = '\\0';
                }
                // Process command
                if (matches == -1) {
                    //printf("Error: could not interpret message %s\\n", message + 1);
                }else if (matches == 1) {
                    if (strncmp(command, "quit", IGS_MAX_LOG_LENGTH) == 0){
                        break;
                    }else if(strncmp(command, "help", IGS_MAX_LOG_LENGTH) == 0){
                        print_cli_usage();
                    }else {
                        printf("Received command: %s\\n", command);
                    }
                }else if (matches == 2) {
                    printf("Received command: %s + %s\\n", command, param1);
                }else if (matches == 3) {
                    printf("Received command: %s + %s + %s\\n", command, param1, param2);
                }else{
                    printf("Error: message returned %d matches (%s)\\n", matches, message);
                }
            }
        }
    }

.for swaggers. as server
    $(server.name:camel)_destroyActor(&$(server.name:camel)Actor);
.endfor
    igs_stop();
    return 0;
}

.
.####################################################################################
.echo "Generating packaging/windows/getopt.h ..."
.output "packaging/windows/getopt.h"
#ifndef __GETOPT_H__
/**
 * DISCLAIMER
 * This file is part of the mingw-w64 runtime package.
 *
 * The mingw-w64 runtime package and its code is distributed in the hope that it
 * will be useful but WITHOUT ANY WARRANTY.  ALL WARRANTIES, EXPRESSED OR
 * IMPLIED ARE HEREBY DISCLAIMED.  This includes but is not limited to
 * warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */
 /*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#pragma warning(disable:4996)

#define __GETOPT_H__

/* All the headers include this file. */
#include <crtdefs.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define    REPLACE_GETOPT        /* use this getopt as the system getopt(3) */

#ifdef REPLACE_GETOPT
int    opterr = 1;        /* if error message should be printed */
int    optind = 1;        /* index into parent argv vector */
int    optopt = '?';        /* character checked for validity */
#undef    optreset        /* see getopt.h */
#define    optreset        __mingw_optreset
int    optreset;        /* reset getopt */
char    *optarg;        /* argument associated with option */
#endif

//extern int optind;        /* index of first non-option in argv      */
//extern int optopt;        /* single option character, as parsed     */
//extern int opterr;        /* flag to enable built-in diagnostics... */
//                /* (user may set to zero, to suppress)    */
//
//extern char *optarg;        /* pointer to argument of current option  */

#define PRINT_ERROR    ((opterr) && (*options != ':'))

#define FLAG_PERMUTE    0x01    /* permute non-options to the end of argv */
#define FLAG_ALLARGS    0x02    /* treat non-options as args to option "-1" */
#define FLAG_LONGONLY    0x04    /* operate as getopt_long_only */

/* return values */
#define    BADCH        (int)'?'
#define    BADARG        ((*options == ':') ? (int)':' : (int)'?')
#define    INORDER     (int)1

#ifndef __CYGWIN__
#define __progname __argv[0]
#else
extern char __declspec(dllimport) *__progname;
#endif

#ifdef __CYGWIN__
static char EMSG[] = "";
#else
#define    EMSG        ""
#endif

struct option        /* specification for a long form option...    */
{
  const char *name;        /* option name, without leading hyphens */
  int         has_arg;        /* does it take an argument?        */
  int        *flag;        /* where to save its status, or NULL    */
  int         val;        /* its associated status value        */
};

static int getopt_internal(int, char * const *, const char *,
                           const struct option *, int *, int);
static int parse_long_options(char * const *, const char *,
                              const struct option *, int *, int);
static int gcd(int, int);
static void permute_args(int, int, int, char * const *);

static char *place = EMSG; /* option letter processing */

/* XXX: set optreset to 1 rather than these two */
static int nonopt_start = -1; /* first non option argument (for permute) */
static int nonopt_end = -1;   /* first option after non options (for permute) */

/* Error messages */
static const char recargchar[] = "option requires an argument -- %c";
static const char recargstring[] = "option requires an argument -- %s";
static const char ambig[] = "ambiguous option -- %.*s";
static const char noarg[] = "option doesn't take an argument -- %.*s";
static const char illoptchar[] = "unknown option -- %c";
static const char illoptstring[] = "unknown option -- %s";

static void
_vwarnx(const char *fmt,va_list ap)
{
  (void)fprintf(stderr,"%s: ",__progname);
  if (fmt != NULL)
    (void)vfprintf(stderr,fmt,ap);
  (void)fprintf(stderr,"\\n");
}

static void
warnx(const char *fmt,...)
{
  va_list ap;
  va_start(ap,fmt);
  _vwarnx(fmt,ap);
  va_end(ap);
}

/*
 * Compute the greatest common divisor of a and b.
 */
static int
gcd(int a, int b)
{
        int c;

        c = a % b;
        while (c != 0) {
                a = b;
                b = c;
                c = a % b;
        }

        return (b);
}

/*
 * Exchange the block from nonopt_start to nonopt_end with the block
 * from nonopt_end to opt_end (keeping the same order of arguments
 * in each block).
 */
static void
permute_args(int panonopt_start, int panonopt_end, int opt_end,
        char * const *nargv)
{
        int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
        char *swap;

        /*
         * compute lengths of blocks and number and size of cycles
         */
        nnonopts = panonopt_end - panonopt_start;
        nopts = opt_end - panonopt_end;
        ncycle = gcd(nnonopts, nopts);
        cyclelen = (opt_end - panonopt_start) / ncycle;

        for (i = 0; i < ncycle; i++) {
                cstart = panonopt_end+i;
                pos = cstart;
                for (j = 0; j < cyclelen; j++) {
                        if (pos >= panonopt_end)
                                pos -= nnonopts;
                        else
                                pos += nopts;
                        swap = nargv[pos];
                        /* LINTED const cast */
                        ((char **) nargv)[pos] = nargv[cstart];
                        /* LINTED const cast */
                        ((char **)nargv)[cstart] = swap;
                }
        }
}

#ifdef REPLACE_GETOPT
/*
 * getopt --
 *    Parse argc/argv argument vector.
 *
 * [eventually this will replace the BSD getopt]
 */
int
getopt(int nargc, char * const *nargv, const char *options)
{

        /*
         * We don't pass FLAG_PERMUTE to getopt_internal() since
         * the BSD getopt(3) (unlike GNU) has never done this.
         *
         * Furthermore, since many privileged programs call getopt()
         * before dropping privileges it makes sense to keep things
         * as simple (and bug-free) as possible.
         */
        return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
}
#endif /* REPLACE_GETOPT */

//extern int getopt(int nargc, char * const *nargv, const char *options);

#ifdef _BSD_SOURCE
/*
 * BSD adds the non-standard `optreset' feature, for reinitialisation
 * of `getopt' parsing.  We support this feature, for applications which
 * proclaim their BSD heritage, before including this header; however,
 * to maintain portability, developers are advised to avoid it.
 */
# define optreset  __mingw_optreset
extern int optreset;
#endif
#ifdef __cplusplus
}
#endif
/*
 * POSIX requires the `getopt' API to be specified in `unistd.h';
 * thus, `unistd.h' includes this header.  However, we do not want
 * to expose the `getopt_long' or `getopt_long_only' APIs, when
 * included in this manner.  Thus, close the standard __GETOPT_H__
 * declarations block, and open an additional __GETOPT_LONG_H__
 * specific block, only when *not* __UNISTD_H_SOURCED__, in which
 * to declare the extended API.
 */
#endif /* !defined(__GETOPT_H__) */

#if !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__)
#define __GETOPT_LONG_H__

#ifdef __cplusplus
extern "C" {
#endif

enum            /* permitted values for its `has_arg' field...    */
{
  no_argument = 0,          /* option never takes an argument    */
  required_argument,        /* option always requires an argument    */
  optional_argument        /* option may take an argument        */
};

/*
 * parse_long_options --
 *    Parse long options in argc/argv argument vector.
 * Returns -1 if short_too is set and the option does not match long_options.
 */
static int
parse_long_options(char * const *nargv, const char *options,
        const struct option *long_options, int *idx, int short_too)
{
        char *current_argv, *has_equal;
        size_t current_argv_len;
        int i, ambiguous, match;

#define IDENTICAL_INTERPRETATION(_x, _y)                                \
        (long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
         long_options[(_x)].flag == long_options[(_y)].flag &&          \
         long_options[(_x)].val == long_options[(_y)].val)

        current_argv = place;
        match = -1;
        ambiguous = 0;

        optind++;

        if ((has_equal = strchr(current_argv, '=')) != NULL) {
                /* argument found (--option=arg) */
                current_argv_len = has_equal - current_argv;
                has_equal++;
        } else
                current_argv_len = strlen(current_argv);

        for (i = 0; long_options[i].name; i++) {
                /* find matching long option */
                if (strncmp(current_argv, long_options[i].name,
                    current_argv_len))
                        continue;

                if (strlen(long_options[i].name) == current_argv_len) {
                        /* exact match */
                        match = i;
                        ambiguous = 0;
                        break;
                }
                /*
                 * If this is a known short option, don't allow
                 * a partial match of a single character.
                 */
                if (short_too && current_argv_len == 1)
                        continue;

                if (match == -1)    /* partial match */
                        match = i;
                else if (!IDENTICAL_INTERPRETATION(i, match))
                        ambiguous = 1;
        }
        if (ambiguous) {
                /* ambiguous abbreviation */
                if (PRINT_ERROR)
                        warnx(ambig, (int)current_argv_len,
                             current_argv);
                optopt = 0;
                return (BADCH);
        }
        if (match != -1) {        /* option found */
                if (long_options[match].has_arg == no_argument
                    && has_equal) {
                        if (PRINT_ERROR)
                                warnx(noarg, (int)current_argv_len,
                                     current_argv);
                        /*
                         * XXX: GNU sets optopt to val regardless of flag
                         */
                        if (long_options[match].flag == NULL)
                                optopt = long_options[match].val;
                        else
                                optopt = 0;
                        return (BADARG);
                }
                if (long_options[match].has_arg == required_argument ||
                    long_options[match].has_arg == optional_argument) {
                        if (has_equal)
                                optarg = has_equal;
                        else if (long_options[match].has_arg ==
                            required_argument) {
                                /*
                                 * optional argument doesn't use next nargv
                                 */
                                optarg = nargv[optind++];
                        }
                }
                if ((long_options[match].has_arg == required_argument)
                    && (optarg == NULL)) {
                        /*
                         * Missing argument; leading ':' indicates no error
                         * should be generated.
                         */
                        if (PRINT_ERROR)
                                warnx(recargstring,
                                    current_argv);
                        /*
                         * XXX: GNU sets optopt to val regardless of flag
                         */
                        if (long_options[match].flag == NULL)
                                optopt = long_options[match].val;
                        else
                                optopt = 0;
                        --optind;
                        return (BADARG);
                }
        } else {            /* unknown option */
                if (short_too) {
                        --optind;
                        return (-1);
                }
                if (PRINT_ERROR)
                        warnx(illoptstring, current_argv);
                optopt = 0;
                return (BADCH);
        }
        if (idx)
                *idx = match;
        if (long_options[match].flag) {
                *long_options[match].flag = long_options[match].val;
                return (0);
        } else
                return (long_options[match].val);
#undef IDENTICAL_INTERPRETATION
}

/*
 * getopt_internal --
 *    Parse argc/argv argument vector.  Called by user level routines.
 */
static int
getopt_internal(int nargc, char * const *nargv, const char *options,
        const struct option *long_options, int *idx, int flags)
{
        char *oli;                /* option letter list index */
        int optchar, short_too;
        static int posixly_correct = -1;

        if (options == NULL)
                return (-1);

        /*
         * XXX Some GNU programs (like cvs) set optind to 0 instead of
         * XXX using optreset.  Work around this braindamage.
         */
        if (optind == 0)
                optind = optreset = 1;

        /*
         * Disable GNU extensions if POSIXLY_CORRECT is set or options
         * string begins with a '+'.
         *
         * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
         *                 optreset != 0 for GNU compatibility.
         */
        if (posixly_correct == -1 || optreset != 0)
                posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
        if (*options == '-')
                flags |= FLAG_ALLARGS;
        else if (posixly_correct || *options == '+')
                flags &= ~FLAG_PERMUTE;
        if (*options == '+' || *options == '-')
                options++;

        optarg = NULL;
        if (optreset)
                nonopt_start = nonopt_end = -1;
start:
        if (optreset || !*place) {        /* update scanning pointer */
                optreset = 0;
                if (optind >= nargc) {          /* end of argument vector */
                        place = EMSG;
                        if (nonopt_end != -1) {
                                /* do permutation, if we have to */
                                permute_args(nonopt_start, nonopt_end,
                                    optind, nargv);
                                optind -= nonopt_end - nonopt_start;
                        }
                        else if (nonopt_start != -1) {
                                /*
                                 * If we skipped non-options, set optind
                                 * to the first of them.
                                 */
                                optind = nonopt_start;
                        }
                        nonopt_start = nonopt_end = -1;
                        return (-1);
                }
                if (*(place = nargv[optind]) != '-' ||
                    (place[1] == '\\0' && strchr(options, '-') == NULL)) {
                        place = EMSG;        /* found non-option */
                        if (flags & FLAG_ALLARGS) {
                                /*
                                 * GNU extension:
                                 * return non-option as argument to option 1
                                 */
                                optarg = nargv[optind++];
                                return (INORDER);
                        }
                        if (!(flags & FLAG_PERMUTE)) {
                                /*
                                 * If no permutation wanted, stop parsing
                                 * at first non-option.
                                 */
                                return (-1);
                        }
                        /* do permutation */
                        if (nonopt_start == -1)
                                nonopt_start = optind;
                        else if (nonopt_end != -1) {
                                permute_args(nonopt_start, nonopt_end,
                                    optind, nargv);
                                nonopt_start = optind -
                                    (nonopt_end - nonopt_start);
                                nonopt_end = -1;
                        }
                        optind++;
                        /* process next argument */
                        goto start;
                }
                if (nonopt_start != -1 && nonopt_end == -1)
                        nonopt_end = optind;

                /*
                 * If we have "-" do nothing, if "--" we are done.
                 */
                if (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {
                        optind++;
                        place = EMSG;
                        /*
                         * We found an option (--), so if we skipped
                         * non-options, we have to permute.
                         */
                        if (nonopt_end != -1) {
                                permute_args(nonopt_start, nonopt_end,
                                    optind, nargv);
                                optind -= nonopt_end - nonopt_start;
                        }
                        nonopt_start = nonopt_end = -1;
                        return (-1);
                }
        }

        /*
         * Check long options if:
         *  1) we were passed some
         *  2) the arg is not just "-"
         *  3) either the arg starts with -- we are getopt_long_only()
         */
        if (long_options != NULL && place != nargv[optind] &&
            (*place == '-' || (flags & FLAG_LONGONLY))) {
                short_too = 0;
                if (*place == '-')
                        place++;        /* --foo long option */
                else if (*place != ':' && strchr(options, *place) != NULL)
                        short_too = 1;        /* could be short option too */

                optchar = parse_long_options(nargv, options, long_options,
                    idx, short_too);
                if (optchar != -1) {
                        place = EMSG;
                        return (optchar);
                }
        }

        if ((optchar = (int)*place++) == (int)':' ||
            (optchar == (int)'-' && *place != '\\0') ||
            (oli = (char *)strchr(options, optchar)) == NULL) {
                /*
                 * If the user specified "-" and  '-' isn't listed in
                 * options, return -1 (non-option) as per POSIX.
                 * Otherwise, it is an unknown option character (or ':').
                 */
                if (optchar == (int)'-' && *place == '\\0')
                        return (-1);
                if (!*place)
                        ++optind;
                if (PRINT_ERROR)
                        warnx(illoptchar, optchar);
                optopt = optchar;
                return (BADCH);
        }
        if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
                /* -W long-option */
                if (*place)            /* no space */
                        /* NOTHING */;
                else if (++optind >= nargc) {    /* no arg */
                        place = EMSG;
                        if (PRINT_ERROR)
                                warnx(recargchar, optchar);
                        optopt = optchar;
                        return (BADARG);
                } else                /* white space */
                        place = nargv[optind];
                optchar = parse_long_options(nargv, options, long_options,
                    idx, 0);
                place = EMSG;
                return (optchar);
        }
        if (*++oli != ':') {            /* doesn't take argument */
                if (!*place)
                        ++optind;
        } else {                /* takes (optional) argument */
                optarg = NULL;
                if (*place)            /* no white space */
                        optarg = place;
                else if (oli[1] != ':') {    /* arg not optional */
                        if (++optind >= nargc) {    /* no arg */
                                place = EMSG;
                                if (PRINT_ERROR)
                                        warnx(recargchar, optchar);
                                optopt = optchar;
                                return (BADARG);
                        } else
                                optarg = nargv[optind];
                }
                place = EMSG;
                ++optind;
        }
        /* dump back option letter */
        return (optchar);
}

/*
 * getopt_long --
 *    Parse argc/argv argument vector.
 */
int
getopt_long(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

        return (getopt_internal(nargc, nargv, options, long_options, idx,
            FLAG_PERMUTE));
}

/*
 * getopt_long_only --
 *    Parse argc/argv argument vector.
 */
int
getopt_long_only(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

        return (getopt_internal(nargc, nargv, options, long_options, idx,
            FLAG_PERMUTE|FLAG_LONGONLY));
}

//extern int getopt_long(int nargc, char * const *nargv, const char *options,
//    const struct option *long_options, int *idx);
//extern int getopt_long_only(int nargc, char * const *nargv, const char *options,
//    const struct option *long_options, int *idx);
/*
 * Previous MinGW implementation had...
 */
#ifndef HAVE_DECL_GETOPT
/*
 * ...for the long form API only; keep this for compatibility.
 */
# define HAVE_DECL_GETOPT    1
#endif

#ifdef __cplusplus
}
#endif

#endif /* !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__) */

.
.####################################################################################
.echo "Generating packaging/unix/install_script.sh ..."
.output "packaging/unix/install_script.sh"
#!/usr/bin/env bash

# Checks whether the current user is root or not and make use of 'sudo' if needed.
function _check_sudo {
    if [[ $EUID = 0 ]]
    then
        $@
    else
        echo "WARNING: You need an elevated prompt to install the ingescape library"
        sudo $@
    fi
}

## Initialisation

# Exit on error
set -o errexit

# Exit on unknown variable used
set -o nounset

# Return code for piped sequences is the last command that returned non-zero (we don't have pipes for now)
set -o pipefail

echo "Installing ingescape and its dependencies..."
echo "-----------------------"
_check_sudo cp -rv . /usr/local/

echo ""
echo "Installation completed with success!"

## EOF ##
.
.####################################################################################
.echo "Generating .gitignore ..."
.output ".gitignore"
# Ignore compiled files
*.o

#Xcode files
*.xcodeproj
#Ignore build Xcode Path
build-xcode
Debug
Release
SharedPrecompiledHeaders
*.build
#Ignore Xcode User Pref
xcuserdata
xcshareddata

#VS files
*.vscode

.
.####################################################################################
.echo "Generating .gitmodules ..."
.output ".gitmodules"
[submodule "dependencies/libwebsockets"]
	path = dependencies/libwebsockets
	url = ssh://git@gitlab.ingescape.com:22222/third-party/libwebsockets.git
	branch = v4.3-stable
[submodule "dependencies/openssl"]
	path = dependencies/openssl
	url = ssh://git@gitlab.ingescape.com:22222/third-party/openssl.git
	branch = OpenSSL_1_1_1-stable

.
.####################################################################################
.echo "Generating bootstrap.sh ..."
.output "bootstrap.sh"
#!/bin/sh

set -e

[[ ! -d .git ]] && echo "Initializing a git repository first..." && git init

git config -f .gitmodules --get-regexp '^submodule\..*\.path\$' |
    while read path_key path
    do
        url_key=\$(echo \$path_key | sed 's/\.path/.url/')
        url=\$(git config -f .gitmodules --get "\$url_key")
        branch_key=\$(echo $path_key | sed 's/\.path/.branch/')
        branch=\$(git config -f .gitmodules --get "\$branch_key" 2> /dev/null || true)

        if [[ -z \$branch ]]
        then
            git submodule add \$url \$path
        else
            git submodule add -b \$branch \$url \$path
        fi
    done
.
.####################################################################################
.echo "Generating CMakeLists.txt ..."
.output "CMakeLists.txt"
cmake_minimum_required(VERSION 3.16)
project($(project.name:no))
set (VERSION "1.0.0")

set(CMAKE_MODULES_DIR "${CMAKE_CURRENT_SOURCE_DIR}/builds/cmake")
list(APPEND CMAKE_MODULE_PATH ${CMAKE_MODULES_DIR})
include(IdentifyOS)

# agent and external dependencies (if any)
add_executable(${PROJECT_NAME}
.for swaggers. as server
    src/$(server.name:camel).c
.endfor
    src/main.c)

# Override default release flags to not define NDEBUG, which CMake sets by default for Release builds
# NB: The NDEBUG flag compile out all assert() calls, skipping whatever was done in the assert call (function call, computation, etc.)
# It changes the compiled code from the source code and we don't want that.
if (NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
   # Enable assertions in release mode
   message(STATUS "Enable C asserts in release mode (instead of noop)")
   if (MSVC)
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL}")

       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL}")

       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_MINSIZEREL}")

       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_MINSIZEREL}")
   else()
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL}")

       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_MINSIZEREL}")
   endif()
endif()

target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src) # local headers

if (WIN32)
    target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/packaging/windows)
endif (WIN32)

find_package (sodium)
find_package (ZeroMQ 4.3.3 REQUIRED)
if (ZeroMQ_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE libzmq)
else (ZeroMQ_FOUND)
    message(FATAL_ERROR "ZeroMQ - Dependency not found")
endif (ZeroMQ_FOUND)

find_package (czmq 4.2.1 REQUIRED)
if (czmq_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE czmq)
else (czmq_FOUND)
    message(FATAL_ERROR "czmq - Dependency not found")
endif (czmq_FOUND)

find_package (zyre 2.0.1 REQUIRED)
if (zyre_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE zyre)
else (zyre_FOUND)
    message(FATAL_ERROR "zyre - Dependency not found")
endif (zyre_FOUND)

find_package (ingescape 3.1 REQUIRED)
if (ingescape_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE ingescape)
else (ingescape_FOUND)
    message(FATAL_ERROR "ingescape - Dependency not found")
endif (ingescape_FOUND)

# lws & openssl
if(UNIX)
    include(ExternalProject)
    set(LWS_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/libwebsockets)
    set(OPENSSL_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/openssl)

    if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
        ExternalProject_Add(
            openssl_external
            SOURCE_DIR ${OPENSSL_SOURCE_DIR}
            CONFIGURE_COMMAND ${CMAKE_COMMAND} -E echo "No configuration needed"
            BUILD_COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/openssl/openssl_universal_binaries.sh
            INSTALL_COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/openssl/_prefix-universal ${CMAKE_CURRENT_BINARY_DIR}/openssl_universal
        )

        ExternalProject_Add(
            lws_external
            SOURCE_DIR ${LWS_SOURCE_DIR}
            CMAKE_ARGS "-DCMAKE_OSX_ARCHITECTURES=x86_64|arm64" -DLWS_WITH_SSL=ON -DLWS_OPENSSL_INCLUDE_DIRS=${CMAKE_CURRENT_BINARY_DIR}/openssl_universal/include -DLWS_OPENSSL_LIBRARIES=${CMAKE_CURRENT_BINARY_DIR}/openssl_universal/lib/libcrypto.a|${CMAKE_CURRENT_BINARY_DIR}/openssl_universal/lib/libssl.a
            LIST_SEPARATOR |
            BUILD_COMMAND make -j8
            INSTALL_COMMAND make DESTDIR=${CMAKE_CURRENT_BINARY_DIR}/ install
        )
        target_link_libraries (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/usr/local/lib/libwebsockets.a)
        target_link_libraries (${PROJECT_NAME} PRIVATE
            ${CMAKE_CURRENT_BINARY_DIR}/openssl_universal/lib/libssl.a
            ${CMAKE_CURRENT_BINARY_DIR}/openssl_universal/lib/libcrypto.a
        )
        target_include_directories (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/openssl_universal/include)
    elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        set(OPENSSL_ROOT_DIR ${CMAKE_CURRENT_BINARY_DIR}/openssl/usr/local)
        ExternalProject_Add(
            openssl_external
            SOURCE_DIR ${OPENSSL_SOURCE_DIR}
            CONFIGURE_COMMAND ${OPENSSL_SOURCE_DIR}/config
            BUILD_COMMAND make -j8
            BUILD_IN_SOURCE ON
            INSTALL_COMMAND make DESTDIR=${CMAKE_CURRENT_BINARY_DIR}/openssl install_sw
        )

        ExternalProject_Add(
            lws_external
            SOURCE_DIR ${LWS_SOURCE_DIR}
            CMAKE_ARGS -DLWS_WITH_SSL=ON -DLWS_OPENSSL_INCLUDE_DIRS=${OPENSSL_ROOT_DIR}/include -DLWS_OPENSSL_LIBRARIES=${OPENSSL_ROOT_DIR}/lib/libcrypto.so|${OPENSSL_ROOT_DIR}/lib/libssl.so
            LIST_SEPARATOR |
            BUILD_COMMAND make -j8
            INSTALL_COMMAND make DESTDIR=${CMAKE_CURRENT_BINARY_DIR}/ install
        )
        target_link_libraries (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/usr/local/lib/libwebsockets.a)
        target_link_libraries (${PROJECT_NAME} PRIVATE
            ${OPENSSL_ROOT_DIR}/lib/libssl.a
            ${OPENSSL_ROOT_DIR}/lib/libcrypto.a
        )
        target_include_directories (${PROJECT_NAME} PRIVATE ${OPENSSL_ROOT_DIR}/include)
    endif()

    add_dependencies(lws_external openssl_external)
    add_dependencies(${PROJECT_NAME} lws_external)
    target_include_directories (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/usr/local/include)

    if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        target_link_libraries(${PROJECT_NAME} PRIVATE ${CMAKE_DL_LIBS})
    endif()
  elseif(WIN32)
        math(EXPR BITS "8*${CMAKE_SIZEOF_VOID_P}")
        option(LWS_USE_OPENSSL "Enable open ssl in libwebsocket" OFF)

        if(LWS_USE_OPENSSL)
            target_include_directories (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/windows/include_libwebsocket_withSSL)
            target_link_libraries (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/windows/lib${BITS}/libwebsocket_withSSL/libcrypto_static.lib)
            target_link_libraries (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/windows/lib${BITS}/libwebsocket_withSSL/libssl_static.lib)
            target_link_libraries (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/windows/lib${BITS}/libwebsocket_withSSL/websockets_static.lib)
        else()
            target_include_directories (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/windows/include_libwebsocket_withoutSSL)
            target_link_libraries (${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dependencies/windows/lib${BITS}/libwebsocket_withoutSSL/websockets_static.lib)
        endif()
  else()
        message(FATAL_ERROR "UNIX or WIN32 not defined, can not create make file")
  endif(UNIX)

########################################################################
# installer
########################################################################
# Package installer for release build only
if (CMAKE_BUILD_TYPE STREQUAL "Release")
    set(CPACK_PACKAGE_NAME "${PROJECT_NAME}")
    set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "${PROJECT_NAME} ingescape agent")
    set(CPACK_PACKAGE_DESCRIPTION "${PROJECT_NAME} ingescape agent")
    set(CPACK_PACKAGE_HOMEPAGE_URL "https://ingescape.com")
    set(CPACK_PACKAGE_VENDOR "Ingescape Circle")
    set(CPACK_PACKAGE_CONTACT "")
    set(CPACK_PACKAGE_VERSION ${VERSION})
    set(CPACK_STRIP_FILES TRUE)

    set(CPACK_SOURCE_IGNORE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/.git/;${CMAKE_CURRENT_SOURCE_DIR}/build/")

    if (WIN32)
        # Installers for 32- vs. 64-bit CMake:
        #  - Root install directory (displayed to end user at installer-run time)
        #  - "NSIS package/display name" (text used in the installer GUI)
        #  - Registry key used to store info about the installation
        if(CMAKE_CL_64)
            set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES64")
            set(CPACK_NSIS_PACKAGE_NAME "${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION} (Win64)")
            set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "${CPACK_PACKAGE_NAME} (Win64)")
        else()
            set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES")
            set(CPACK_NSIS_PACKAGE_NAME "${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION}")
            set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "${CPACK_PACKAGE_NAME} (Win32)")
        endif()

        # On windows put all agents in ingescape directory
        set(CPACK_PACKAGE_INSTALL_DIRECTORY "ingescape")

        # NSIS configuration for Windows
        set(CPACK_NSIS_DISPLAY_NAME "${PROJECT_NAME}")
        set(CPACK_NSIS_PACKAGE_NAME ${PROJECT_NAME})
        set(CPACK_NSIS_HELP_LINK "https://ingescape.com")
        set(CPACK_NSIS_CONTACT "contact@ingescape.com")

        set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL ON)
        set(CPACK_NSIS_MODIFY_PATH OFF)
        set(CPACK_NSIS_URL_INFO_ABOUT ${CMAKE_PROJECT_HOMEPAGE_URL})
        set(CPACK_MONOLITHIC_INSTALL ON)
        set(CPACK_GENERATOR "NSIS;ZIP")

    elseif ( ${CMAKE_SYSTEM_NAME} MATCHES "Darwin" )
        # Without component productbuild will not package any files
        set (CPACK_COMPONENTS_ALL agent)
        set(CPACK_PACKAGING_INSTALL_PREFIX "/usr/local")
        set(CPACK_PACKAGING_INSTALL_PREFIX "/usr/local")
        set(CPACK_SYSTEM_NAME "macos")
        set(CPACK_GENERATOR "productbuild;ZIP")

        configure_file("${CMAKE_CURRENT_SOURCE_DIR}/LICENSE" "${CMAKE_BINARY_DIR}/LICENSE.txt" COPYONLY)
        set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_BINARY_DIR}/LICENSE.txt")

    else ()
        set(CPACK_MONOLITHIC_INSTALL ON)
        install(FILES "${CMAKE_CURRENT_SOURCE_DIR}/packaging/unix/install_script.sh"
                DESTINATION "."
                PERMISSIONS OWNER_READ OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE
                COMPONENT agent)
        set(CPACK_GENERATOR "TGZ")
    endif ()

    include (CPack)
endif()

# ##############################################################################
# summary
# ##############################################################################
message("")
message(STATUS "******************* Configuration Summary *******************")
message(STATUS "General:")
message(STATUS "  Version           :   ${VERSION}")
message(STATUS "  System            :   ${CMAKE_SYSTEM_NAME}")
message(STATUS "  C compiler        :   ${CMAKE_C_COMPILER}")
message(
STATUS "  Debug C flags     :   ${CMAKE_C_FLAGS_DEBUG} ${CMAKE_C_FLAGS}")
message(
STATUS "  Release C flags   :   ${CMAKE_C_FLAGS_RELEASE} ${CMAKE_C_FLAGS}")
message(STATUS "  Build type        :   ${CMAKE_BUILD_TYPE}")
message(STATUS "")
message(STATUS "Dependencies:")
include(FeatureSummary)
feature_summary(WHAT ALL FATAL_ON_MISSING_REQUIRED_PACKAGES)
message(STATUS "")
message(STATUS "Install:")
message(STATUS "  Install prefix    :   ${CMAKE_INSTALL_PREFIX}")
message(STATUS "")
if(NOT MSVC)
    message(
        STATUS "*************************************************************")
    message(STATUS "Configuration complete! Now procced with:")
    message(STATUS "  'make'                compile the project")
    message(
        STATUS
        "  'make install'        install the project to ${CMAKE_INSTALL_PREFIX}")
    message(
        STATUS
        "  'make uninstall'      uninstall the project from ${CMAKE_INSTALL_PREFIX}"
        )
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        message(STATUS "  'make package'        Create library installer")
    endif()
endif()
message(STATUS "")
.
.
.####################################################################################
.echo "Generating other static files ..."
.output "LICENSE"
Add your license here
.
.####################################################################################
.echo "Generating README.md ..."
.output "README.md"
# $(project.name:no)

Once generated, you can setup a git repository with these commands:

    chmod +x bootstrap.sh
    ./bootstrap.sh

The structure of this directory and the specifics of each folder are listed below.
For more in depth detail on each folder, navigate to that folder to view its specific README.md

```
  README.md
  builds
  dependencies
  packaging
  src
```

The **builds** folder contains utility files for build (CMake, etc.).

The **dependencies** folder contains other GIT repositories as sub-modules (libwebsockets, openssl, etc.).

The **packaging** folder contains utility files for packaging.

The **src** folder contains the source files of the application.
.
.endfor
.endfor
.endtemplate
