.template 0

#############################################################################
# Generic helpers
#

function getIndent(level)
    return " " * my.level * global.sketch2qml_tabWidth 
endfunction getIndent


function getAppOrLibrarySubPath(value)
    if regexp.match("([^\\.]+)\\.(.*)$", my.value, leftPart, rightPart)
        return "$(leftPart:Pascal)/" + getAppOrLibrarySubPath(rightPart)
    else
        return "$(my.value:Pascal)"
    endif
endfunction getAppOrLibrarySubPath


function initDirectories()
    directory.create("$(global.sketch2qml_appOrLibraryDir)")
    directory.create("$(global.sketch2qml_appOrLibraryDir)/qml/$(global.sketch2qml_appOrLibrarySubPath)")
    directory.create("$(global.sketch2qml_appOrLibraryDir)/resources/$(global.sketch2qml_appOrLibrarySubPath)")
endfunction initDirectories


function forceCopyFile(sourceFilePath, destinationFilePath)
    if file.exists(my.destinationFilePath)
        file.delete(my.destinationFilePath)
    endif
    if (file.copy(my.sourceFilePath, my.destinationFilePath, "b", my.error) = -1)
        echo "Failed to copy file $(my.sourceFilePath) at $(my.destinationFilePath): $(my.error)" 
    endif
endfunction forceCopyFile


function forceCopyDir(sourceDirPath, destinationDirPath)
    my.cleanSourceDirPath = directory.resolve(my.sourceDirPath)
    my.cleanDestinationDirPath = directory.resolve(my.destinationDirPath)
    my.sourceDir = directory.open (my.cleanSourceDirPath, my.error_text) ? 
    if defined (my.sourceDir)
        directory.create("$(my.cleanDestinationDirPath)")
        for my.sourceDir.file as f
            forceCopyFile("$(f.path)$(f.name)", "$(my.cleanDestinationDirPath)$(f.name)")
        endfor
        for my.sourceDir.directory as d
            forceCopyDir("$(d.path)$(d.name)", "$(my.cleanDestinationDirPath)$(d.name)")
        endfor
    else
        echo "Failed to open directory $(my.cleanSourceDirPath): $(my.error_text)"
    endif
endfunction forceCopyDir


function generateFontsInQRC(appOrLibrary)
    if count(my.appOrLibrary.font) 
        my.fontsSubDir = "resources/$(global.sketch2qml_appOrLibrarySubPath)/fonts"
        my.fontsDir = "$(global.sketch2qml_appOrLibraryDir)/$(my.fontsSubDir)"
        directory.create(my.fontsDir)
        for my.appOrLibrary.font
            echo "Exporting font $(font.file)"
            if regexp.match(".*/([^/]+)$", font.file, fileName)
                forceCopyFile("$(font.file)", "$(my.fontsDir)/$(fileName)")
>        <file>$(my.fontsSubDir)/$(fileName)</file>                
            else
                forceCopyFile("$(font.file)", "$(my.fontsDir)/$(font.file)")
>        <file>$(my.fontsSubDir)/$(font.file)</file>                
            endif
        endfor
    endif
endfunction generateFontsInQRC


function generateImagesInQRC(myItem)
    my.imagesSubDir = "resources/$(global.sketch2qml_appOrLibrarySubPath)/images"
    my.imagesDir = "$(global.sketch2qml_appOrLibraryDir)/$(my.imagesSubDir)"
    # Items exported as images
    if count(my.myItem.export) 
        directory.create(my.imagesDir)
        for my.myItem.export
            echo "Exporting image $(export.file)"
            if regexp.match(".*/([^/]+)$", export.file, fileName)
                forceCopyFile("$(export.file)", "$(my.imagesDir)/$(fileName)")
>        <file>$(my.imagesSubDir)/$(fileName)</file>
            else
                forceCopyFile("$(export.file)", "$(my.imagesDir)/$(export.file)")
>        <file>$(my.imagesSubDir)/$(export.file)</file>
            endif
        endfor
    endif
    # Image overrides
    for my.myItem.override
        if (isImageOverride(override) & !overrideIsDefault(override))
            echo "Exporting image override $(override.value)"
            directory.create(my.imagesDir)
            if regexp.match("^.*/([^/]+)$", override.value, fileName)
                forceCopyFile("$(override.value)", "$(my.imagesDir)/$(fileName)")
>        <file>$(my.imagesSubDir)/$(fileName)</file>
            else
                forceCopyFile("$(override.value)", "$(my.imagesDir)/$(override.value)")
>        <file>$(my.imagesSubDir)/$(override.value)</file>
            endif
        endif
    endfor
    for my.myItem.item
        generateImagesInQRC(item)
    endfor
endfunction generateImagesInQRC


function copyResourcesFiles()
    #add default icons
    if (defined (global.sketch2qml_generateStandaloneApp) & global.sketch2qml_generateStandaloneApp)
        directory.create("$(global.sketch2qml_appOrLibraryDir)")
        file.copy("$(global.sketch2qml_scriptsResourcesDir)/icon.icns", "$(global.sketch2qml_appOrLibraryDir)/icon.icns")
        file.copy("$(global.sketch2qml_scriptsResourcesDir)/icon.icns", "$(global.sketch2qml_appOrLibraryDir)/icon.ico")
    endif

    #I2SketchQuick module
    forceCopyDir("$(global.sketch2qml_scriptsResourcesDir)/I2SketchQuick", "$(global.sketch2qml_appOrLibraryDir)/../I2SketchQuick")
endfunction copyResourcesFiles


function includeExternals(item, component)
    for my.item.external
        echo "found external XML $(external.name) at path $(external.path)"
        xml to my.component from "$(external.path)"
        delete external
    endfor
    for my.item.item
        includeExternals(item, my.component)
    endfor
endfunction includeExternals


function generateCopyright()
    my.subIndent = getIndent(1)

>/*
    if defined(global.project_name)
> *  $(global.project_name)
    else
> *  $(global.sketch2qml_appOrLibraryName)
    endif
> *
    if defined(global.project_copyright)
> *  $(global.project_copyright)
    else
> *  File generated by Ingescape Circle on $(date.picture())
    endif
> *
> *  See license terms for the rights and conditions
> *  defined by copyright holders.
> *
> *  Contributors:
    if defined(global.project_contributor)
> *  $(my.subIndent)$(global.project_contributor)
    endif
> * 
> *
> */
endfunction generateCopyright


function generateIncludePRI(priRelativePath)
>!contains(includedPRIs, $$PWD/$(my.priRelativePath)) {         
>    !include($(my.priRelativePath)) {
>        error(Could not load $(my.priRelativePath))
>    } else {
>        includedPRIs += $$PWD/$(my.priRelativePath)
>    }
>} else {
>    warning($(my.priRelativePath) is already included (line $$_LINE_))
>}
endfunction generateIncludePRI


function generateCommonQmlRegisters()
    # Theme
>    // Theme (colors, fonts)
>    qmlRegisterSingletonType(QUrl("qrc:/qml/$(global.sketch2qml_appOrLibrarySubPath)/$(global.sketch2qml_appOrLibraryName)Theme.qml"), "$(global.sketch2qml_appOrLibraryQmlModule)", 1, 0, "$(global.sketch2qml_appOrLibraryName)Theme");

    # Font loaders
>    //
>    qmlRegisterSingletonType(QUrl("qrc:/qml/$(global.sketch2qml_appOrLibrarySubPath)/$(global.sketch2qml_appOrLibraryName)FontLoaders.qml"), "$(global.sketch2qml_appOrLibraryQmlModule)", 1, 0, "$(global.sketch2qml_appOrLibraryName)FontLoaders");
endfunction generateCommonQmlRegisters


function getAppOrLibraryQmlModuleName(value)
    if regexp.match("([^\\.]+)\\.(.*)$", my.value, leftPart, rightPart)
        return "$(leftPart:Pascal)." + getAppOrLibraryQmlModuleName(rightPart)
    else
        return "$(my.value:Pascal)"
    endif
endfunction getAppOrLibraryQmlModuleName


function importCommonQmlModules()
    if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
>import QtQuick 2.15
>import QtQuick.Controls 2.15
>import QtQuick.Window 2.15
>import QtQuick.Layouts 1.15
>
>import I2SketchQuick 1.0
>import I2SketchQuick.Controls 1.0
    else
>import QtQuick
>import QtQuick.Controls
>import QtQuick.Window
>import QtQuick.Layouts
>
>import I2SketchQuick
>import I2SketchQuick.Controls
    endif
endfunction importCommonQmlModules


function importExtraQmlModules()
    if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
>import I2SketchQuick.Controls.impl 1.0
    else
>import I2SketchQuick.Controls.impl
    endif
endfunction importExtraQmlModules


function importQtQuickTemplates()
    if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
>import QtQuick.Templates 2.15 as T
    else
>import QtQuick.Templates as T
    endif
endfunction importQtQuickTemplates


function importLibraryQmlModule()
    if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
        if global.sketch2qml_isApp
>import $(global.sketch2qml_libraryQmlModule) 1.0
        else
>import $(global.sketch2qml_appOrLibraryQmlModule) 1.0
        endif
    else
        if global.sketch2qml_isApp
>import $(global.sketch2qml_libraryQmlModule)     
        else
>import $(global.sketch2qml_appOrLibraryQmlModule)
        endif
    endif
endfunction importLibraryQmlModule


function importAppAndLibraryQmlModules()
    importLibraryQmlModule()

    if global.sketch2qml_isApp
        if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
>import $(global.sketch2qml_appOrLibraryQmlModule) 1.0
        else
>import $(global.sketch2qml_appOrLibraryQmlModule)
        endif
    endif
endfunction importAppAndLibraryQmlModules


function _importSpecificQmlModules(page)
    for my.page.include
        if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
>import $(include.name: pascal) 1.0
        else       
>import $(include.name: pascal)
        endif
    endfor
    for my.page.item
        _importSpecificQmlModules(item)
    endfor
endfunction _importSpecificQmlModules


function importSpecificQmlModules(appOrLibrary)
    for my.appOrLibrary.page
        _importSpecificQmlModules(page)
    endfor
endfunction importSpecificQmlModules


function getFontQrcUrl(fontFile)
     if regexp.match("^.*/([^/]+)$", my.fontFile, fileName)
        my.file = fileName
     else
        my.file = my.fontFile
    endif

    return "qrc:/resources/$(global.sketch2qml_appOrLibrarySubPath)/fonts/$(my.file)"
endfunction getFontQrcUrl


function getImageQrcUrl(imageFile)
     if regexp.match("^.*/([^/]+)$", my.imageFile, fileName)
        my.file = fileName
     else
        my.file = my.imageFile
    endif
    
    return "qrc:/resources/$(global.sketch2qml_appOrLibrarySubPath)/images/$(my.file)"
endfunction getImageQrcUrl


function hasFixedLeft(item)
    return (defined(my.item.hasFixedLeft) & my.item.hasFixedLeft)
endfunction hasFixedLeft


function hasFixedRight(item)
    return (defined(my.item.hasFixedRight) & my.item.hasFixedRight)
endfunction hasFixedRight


function hasFixedTop(item)
    return (defined(my.item.hasFixedTop) & my.item.hasFixedTop)
endfunction hasFixedTop


function hasFixedBottom(item)
    return (defined(my.item.hasFixedBottom) & my.item.hasFixedBottom)
endfunction hasFixedBottom


function hasFixedWidth(item)
    return (defined(my.item.hasFixedWidth) & my.item.hasFixedWidth)
endfunction hasFixedWidth


function hasFixedHeight(item)
    return (defined(my.item.hasFixedHeight) & my.item.hasFixedHeight)
endfunction hasFixedHeight


function needsToDefineWidth(item)
    return (!hasFixedLeft(my.item) | !hasFixedRight(my.item))
endfunction needsToDefineWidth


function needsToDefineHeight(item)
    return (!hasFixedTop(my.item) | !hasFixedBottom(my.item))
endfunction needsToDefineHeight


function canSetLeftAnchor(item, canSetWidth)
    return (hasFixedLeft(my.item) & (!(my.item.x = 0) | hasFixedRight(my.item)))  
endfunction canSetLeftAnchor


function canSetRightAnchor(item, canSetWidth)
    return (hasFixedRight(my.item) & (my.canSetWidth | !hasFixedLeft(my.item)))
endfunction canSetRightAnchor


function canSetTopAnchor(item, canSetHeight)
    return (hasFixedTop(my.item) & (!(my.item.y = 0) | hasFixedBottom(my.item)))
endfunction canSetTopAnchor


function canSetBottomAnchor(item, canSetHeight)
    return (hasFixedBottom(my.item) & (my.canSetHeight | !hasFixedTop(my.item)))
endfunction canSetBottomAnchor


function itemHasResizableWidth(item)
    return (hasFixedLeft(my.item) & hasFixedRight(my.item))
endfunction itemHasResizableWidth


function itemHasResizableHeight(item)
    return (hasFixedTop(my.item) & hasFixedBottom(my.item))
endfunction itemHasResizableHeight


function itemIsResizable(item, canSetWidth, canSetHeight)
    return ((my.canSetWidth & itemHasResizableWidth(my.item)) | (my.canSetHeight & itemHasResizableHeight(my.item)))
endfunction itemIsResizable


function useSharedStyle(item)
    return (defined (my.item.useSharedStyle) & !(my.item.useSharedStyle = 0))
endfunction useSharedStyle


function getChildNamed(parent, targetName)
    if count(my.parent.item)
        for my.parent.item where (string.lexcmp("$(name:camel)", my.targetName) = 0)
            return item
        endfor
    endif
endfunction getChildNamed


function isSymbolInstance(item)
    return (defined(my.item.symbolMaster) & (string.length(my.item.symbolMaster) > 0) & !isImage(my.item))
endfunction isSymbolInstance


function isImage(item)
    return (my.item.type = "image")
endfunction isImage


function isText(item)
    return (my.item.type = "text")
endfunction isText


function isRectangle(item)
    return (my.item.type = "rectangle")
endfunction isRectangle


function isOval(item)
    return (my.item.type = "oval")
endfunction isOval


function isLine(item)
    return (my.item.type = "line")
endfunction isLine


function isGroup(item)
    return (my.item.type = "group")
endfunction isGroup


function useAsMask(item)
    return (defined (my.item.isMask) & my.item.isMask)
endfunction useAsMask


function hasAutoWidthTextBehaviour(item)
    return (defined(my.item.textBehaviour) & (my.item.textBehaviour = "autoWidth"))
endfunction hasAutoWidthTextBehaviour


function hasAutoHeightTextBehaviour(item)
    return (defined(my.item.textBehaviour) & (my.item.textBehaviour = "autoHeight"))
endfunction hasAutoHeightTextBehaviour


function hasFixedSizeTextBehaviour(item)
    return (defined(my.item.textBehaviour) & (my.item.textBehaviour = "fixedSize"))
endfunction hasFixedSizeTextBehaviour


function isSharedStyleOutOfSync(item)
    return (defined(my.item.isSharedStyleOutOfSync) & my.item.isSharedStyleOutOfSync)
endfunction isSharedStyleOutOfSync


function overrideIsDefault(override)
    return (defined(my.override.isDefault) & my.override.isDefault)
endfunction overrideIsDefault


function overrideIsEditable(override)
    return (defined(my.override.editable) & my.override.editable)
endfunction overrideIsEditable


function isImageOverride(override)
    return (my.override.property = "image")
endfunction isImageOverride


function isSymbolOverride(override)
    return (my.override.property = "symbolID")
endfunction isSymbolOverride


function isTextStyleOverride(override)
    return (my.override.property = "textStyle")
endfunction isTextStyleOverride


function isStringValueOverride(override)
    return (my.override.property = "stringValue")
endfunction isStringValueOverride


function isLayerStyleOverride(override)
    return (my.override.property = "layerStyle")
endfunction isLayerStyleOverride


function currentComponentHasSymbolOverrideForItem(item)
    my.name = "$(my.item.name:camel)"

    if defined(global.sketch2qml_currentComponent)
        if count(global.sketch2qml_currentComponent.overridable)
            for global.sketch2qml_currentComponent.overridable
                if isSymbolOverride(overridable)
                    if (overridable.on = my.name)
                        return 1
                    endif
                endif
            endfor
        endif
    endif
    
    return 0
endfunction currentComponentHasSymbolOverrideForItem


function currentComponentHasImageOverrideForItem(item)
    my.name = "$(my.item.name:camel)"

    if defined(global.sketch2qml_currentComponent)
        if count(global.sketch2qml_currentComponent.overridable)
            for global.sketch2qml_currentComponent.overridable
                if isImageOverride(overridable)
                    if (overridable.on = my.name)
                        return 1
                    endif
                endif
            endfor
        endif
    endif
    
    return 0
endfunction currentComponentHasImageOverrideForItem


function currentComponentHasTextStyleOverrideForItem(item)
    my.name = "$(my.item.name:camel)"

    if defined(global.sketch2qml_currentComponent)
        if count(global.sketch2qml_currentComponent.overridable)
            for global.sketch2qml_currentComponent.overridable
                if isTextStyleOverride(overridable)
                    if (overridable.on = my.name)
                        return 1
                    endif
                endif
            endfor
        endif
    endif
    
    return 0
endfunction currentComponentHasTextStyleOverrideForItem


function currentComponentHasStringValueOverrideForItem(item)
    my.name = "$(my.item.name:camel)"

    if defined(global.sketch2qml_currentComponent)
        if count(global.sketch2qml_currentComponent.overridable)
            for global.sketch2qml_currentComponent.overridable
                if isStringValueOverride(overridable)
                    if (overridable.on = my.name)
                        return 1
                    endif
                endif
            endfor
        endif
    endif
    
    return 0
endfunction currentComponentHasStringValueOverrideForItem


function currentComponentHasLayerStyleOverrideForItem(item)
    my.name = "$(my.item.name:camel)"

    if defined(global.sketch2qml_currentComponent)
        if count(global.sketch2qml_currentComponent.overridable)
            for global.sketch2qml_currentComponent.overridable
                if isLayerStyleOverride(overridable)
                    if (overridable.on = my.name)
                        return 1
                    endif
                endif
            endfor
        endif
    endif
    
    return 0
endfunction currentComponentHasLayerStyleOverrideForItem



#############################################################################
# C++ files
#
function renderCppGlobalHeader()
    generateCopyright()
>
>#ifndef $(global.sketch2qml_appOrLibraryName:UPPER)_GLOBAL_H
>#define $(global.sketch2qml_appOrLibraryName:UPPER)_GLOBAL_H
>
>#include <QtCore/qglobal.h>
>
>#ifndef QT_STATIC
>  #if defined($(global.sketch2qml_appOrLibraryName:UPPER)_LIBRARY)
>    #define $(global.sketch2qml_appOrLibraryName:UPPER)_EXPORT Q_DECL_EXPORT
>  #elif defined($(global.sketch2qml_appOrLibraryName:UPPER)_NO_EXPORT)
>    #define $(global.sketch2qml_appOrLibraryName:UPPER)_EXPORT
>  #else
>    #define $(global.sketch2qml_appOrLibraryName:UPPER)_EXPORT Q_DECL_IMPORT
>  #endif
>#else
>  #define $(global.sketch2qml_appOrLibraryName:UPPER)_EXPORT    
>#endif  
>
>#endif // $(global.sketch2qml_appOrLibraryName:UPPER)_GLOBAL_H
endfunction renderCppGlobalHeader


function renderCppLibraryHeader()
    generateCopyright()
>
>#ifndef $(global.sketch2qml_appOrLibraryName:UPPER)_QML_H
>#define $(global.sketch2qml_appOrLibraryName:UPPER)_QML_H
>
>#include "$(global.sketch2qml_appOrLibraryName:lower)_global.h"
>
>class $(global.sketch2qml_appOrLibraryName:UPPER)_EXPORT $(global.sketch2qml_appOrLibraryName)Qml
>{
>public:
>    static void registerTypes();
>};
>
>#endif // $(global.sketch2qml_appOrLibraryName:UPPER)_QML_H
endfunction renderCppLibraryHeader


function renderCppLibrarySource(appOrLibrary)
    generateCopyright()
>
>#include "$(global.sketch2qml_appOrLibraryName:lower)_qml.h"
>#include <QQmlEngine>
>
>void $(global.sketch2qml_appOrLibraryName)Qml::registerTypes()
>{
>#ifdef QT_STATIC
>    Q_INIT_RESOURCE($(global.sketch2qml_appOrLibraryName:lower));
>#endif
>
    generateCommonQmlRegisters()
>
    if count(my.appOrLibrary.component)
>    // Project specific items   
        for my.appOrLibrary.component
>    qmlRegisterType(QUrl("qrc:/qml/$(global.sketch2qml_appOrLibrarySubPath)/$(component.type: Pascal).qml"), "$(global.sketch2qml_appOrLibraryQmlModule)", 1, 0, "$(component.type: Pascal)");
        endfor
>
    endif
    if count(my.appOrLibrary.library)
>    // Project specific items        
        for my.appOrLibrary.library
           for library.component
>    qmlRegisterType(QUrl("qrc:/qml/$(global.sketch2qml_appOrLibrarySubPath)/$(component.type: Pascal).qml"), "$(global.sketch2qml_appOrLibraryQmlModule)", 1, 0, "$(component.type: Pascal)");           
           endfor
        endfor
>
    endif
    if count(my.appOrLibrary.page)
>    // Artboards   
        for my.appOrLibrary.page
            for page.screen
>    qmlRegisterType(QUrl("qrc:/qml/$(global.sketch2qml_appOrLibrarySubPath)/$(screen.name: Pascal).qml"), "$(global.sketch2qml_appOrLibraryQmlModule)", 1, 0, "$(screen.name: Pascal)");  
            endfor
        endfor
>
    endif
>} 
endfunction renderCppLibrarySource





#############################################################################
# Generic QML related files (theme, qmldir, qrc)
#

function renderFontLoaders(appOrLibrary)
>pragma Singleton
.importCommonQmlModules()
>
>
>QtObject {
>    id: root

    if count(my.appOrLibrary.font)
>
>
>    //----------------------------------
>    //
>    // Fonts
>    //  
>    //----------------------------------
        for my.appOrLibrary.font
            my.qrcUrl = getFontQrcUrl(font.file)
>
>    readonly property FontLoader fontLoader$(font.name:camel): FontLoader {
>        source: "$(my.qrcUrl)"
>    }
        endfor
    endif
>
>
>    //----------------------------------
>    //
>    // Methods
>    //
>    //----------------------------------
>
>    // To force creation of our singleton
>    function load() {}
>
>}
endfunction renderFontLoaders


function renderTheme(appOrLibrary)
>pragma Singleton
.importCommonQmlModules()
>
>
>QtObject {
>    id: root
>
>
>    //----------------------------------
>    //
>    // Colors
>    //
>    //----------------------------------
>
>    readonly property color mainWindowColor: "#FFFFFF" // Property used to force the creation of our singleton in main.qml
>
    for my.appOrLibrary.swatch
>    readonly property color $(swatch.name:camel): "$(swatch.color)"
    endfor   

    if count(my.appOrLibrary.sharedtextstyle)
>
>
>    //----------------------------------
>    //
>    // Text styles
>    //
>    //---------------------------------- 
        for my.appOrLibrary.sharedtextstyle
>
>    readonly property SketchTextStyle $(sharedtextstyle.name:camel): SketchTextStyle {  
            renderTextStyleProperties(my.appOrLibrary, "", 0, sharedtextstyle, 1, 0)
>    }
        endfor
    endif
>}
endfunction renderTheme


function renderQmldir(appOrLibrary)
    # Declares the module identifier of the module.
    # The <ModuleIdentifier> is the (dotted URI notation) identifier for the module, which must match the module's install path.
    # The module identifier directive must be the first line of the file.
    # Exactly one module identifier directive may exist in the qmldir file.
>module $(global.sketch2qml_appOrLibraryQmlModule)
>
    # Theme
>singleton $(global.sketch2qml_appOrLibraryName)Theme 1.0 $(global.sketch2qml_appOrLibraryName)Theme.qml 

    # Font loaders
>singleton $(global.sketch2qml_appOrLibraryName)FontLoaders 1.0 $(global.sketch2qml_appOrLibraryName)FontLoaders.qml 

>
    # Project specific items
    if count(my.appOrLibrary.component)
        for my.appOrLibrary.component
>$(component.type: Pascal) 1.0 $(component.type: Pascal).qml
        endfor
>
    endif
    if count(my.appOrLibrary.library)
        for my.appOrLibrary.library
            for library.component
>$(component.type: Pascal) 1.0 $(component.type: Pascal).qml
            endfor
        endfor
>
    endif
    # Artboard
    if count(my.appOrLibrary.page)
        for my.appOrLibrary.page
            for page.screen
>$(screen.name: Pascal) 1.0 $(screen.name: Pascal).qml  
            endfor
        endfor
>                
    endif
>
    # Set this property if the library is supported by Qt Quick Designer
    # By default, the library will not be supported.
>designersupported
endfunction renderQmldir


function renderTempMainQrc(appOrLibrary, addStandaloneFiles)
><RCC>
>    <qresource prefix="/">
    #add theme
>        <file>qml/$(global.sketch2qml_appOrLibrarySubPath)/$(global.sketch2qml_appOrLibraryName)Theme.qml</file>

    #add font loaders
>        <file>qml/$(global.sketch2qml_appOrLibrarySubPath)/$(global.sketch2qml_appOrLibraryName)FontLoaders.qml</file>

    # Project specific items
    if count(my.appOrLibrary.component)
        for my.appOrLibrary.component
>        <file>qml/$(global.sketch2qml_appOrLibrarySubPath)/$(component.type: Pascal).qml</file>
            for component.item
                generateImagesInQRC(item)
            endfor
        endfor
    endif
    if count(my.appOrLibrary.library)
        for my.appOrLibrary.library
            for library.component
>        <file>qml/$(global.sketch2qml_appOrLibrarySubPath)/$(component.type: Pascal).qml</file>
                for component.item
                    generateImagesInQRC(item)
                endfor
            endfor
        endfor
    endif    
    
    # Artboard and windows
    if count(my.appOrLibrary.page)
        for my.appOrLibrary.page
            for page.item
                generateImagesInQRC(item)
            endfor
            for page.screen
>        <file>qml/$(global.sketch2qml_appOrLibrarySubPath)/$(screen.name: Pascal).qml</file>
                if (my.addStandaloneFiles)
>        <file>qml/Window$(screen.name: Pascal).qml</file>
                endif
                generateImagesInQRC(screen)
            endfor
        endfor
    endif

    if (my.addStandaloneFiles)
>        <file>qml/main.qml</file>    
    endif
>    </qresource>
></RCC>
endfunction renderTempMainQrc


function renderTempFontsQrc(appOrLibrary)
><RCC>
>    <qresource prefix="/">
    generateFontsInQRC(my.appOrLibrary) 
>    </qresource>
></RCC>
endfunction renderTempFontsQrc


function renderCleanedQrc(tempFile)
    my.qrc ?= xml.load_file (my.tempFile)
><RCC>
>    <qresource prefix="/">
    if defined(my.qrc)
        for my.qrc.qresource
            my.previousFile = ""
            for qresource.file by file
                my.candidateFile = "$(file)"
                if !(my.previousFile = my.candidateFile)
>        <file>$(my.candidateFile)</file>
                    my.previousFile = my.candidateFile                
                endif
            endfor
        endfor
    endif
>    </qresource>
></RCC>
endfunction renderCleanedQrc


#############################################################################
# Generic QML renderers
#

function renderId(item, level)
    my.indent = getIndent(my.level)
>    $(my.indent)id: $(my.item.name:camel)
endfunction renderId


function renderObjectName(item, level)
    my.indent = getIndent(my.level)
>    $(my.indent)objectName: "$(my.item.name:camel)"
endfunction renderObjectName


function renderIdAndObjectName(item, level)
    renderId(my.item, my.level)
    renderObjectName(my.item, my.level)
endfunction renderObjectName


function renderOpacity(prefix, item, level)
    if (defined(my.item.opacity) & !(my.item.opacity = 1))
         my.indent = getIndent(my.level)
         
        if (defined (my.item.isMask) & my.item.isMask)
           # Special case: we can not set the opacity of an item used as a clipping mask 
>    $(my.indent)//$(my.prefix)opacity: $(my.item.opacity)  // Item used as clipping mask, opacity is not relevant            
        else
>    $(my.indent)$(my.prefix)opacity: $(my.item.opacity)
        endif
    endif
endfunction renderOpacity


function changePropertiesToForceAnchorsFillParent(item)
    my.item.hasFixedLeft = 1
    my.item.hasFixedRight = 1
    my.item.hasFixedTop = 1
    my.item.hasFixedBottom = 1
    my.item.x = 0
    my.item.y = 0
    my.item.fixedRight = 0
    my.item.fixedBottom = 0
endfunction changePropertiesToForceAnchorsFillParent


#NB: used when items can not have anchors (e.g. Popups)
function renderItemPositioning_NoAnchors(item, level, canSetWidth, canSetHeight)
    my.indent = getIndent(my.level)
> 
    if (hasFixedLeft(my.item) & hasFixedRight(my.item) & hasFixedTop(my.item) & hasFixedBottom(my.item) & my.canSetWidth & my.canSetHeight)
        # All anchors (left, right, top, bottom)
        if ((my.item.x = 0) & (my.item.fixedRight = 0) & (my.item.y = 0) & (my.item.fixedBottom = 0))
            # No margins
>    $(my.indent)width: parent.width
>    $(my.indent)height: parent.height
        else
            # At least one margin
            if !(my.item.x = 0)
>    $(my.indent)x: $(my.item.x)
            endif
            my.deltaWidth = my.item.x + my.item.fixedRight
            if (my.deltaWidth = 0)
>    $(my.indent)width: parent.width
            else
                if (my.deltaWidth > 0)
>    $(my.indent)width: parent.width - $(my.deltaWidth)
                else
>    $(my.indent)width: parent.width - ($(my.deltaWidth))
                endif
            endif

            if !(my.item.y = 0)
>    $(my.indent)y: $(my.item.y)
            endif
            my.deltaHeight = my.item.y + my.item.fixedBottom
            if (my.deltaHeight = 0)
>    $(my.indent)height: parent.height
            else
                if (my.deltaHeight > 0)
>    $(my.indent)height: parent.height - $(my.deltaHeight)
                else
>    $(my.indent)height: parent.height - ($(my.deltaHeight))
                endif
            endif
        endif
    elsif (hasFixedLeft(my.item) | hasFixedRight(my.item) | hasFixedTop(my.item) | hasFixedBottom(my.item))
        # At least one anchor
        my.usesLeftAnchor = canSetLeftAnchor(my.item, my.canSetWidth)
        my.usesRightAnchor = canSetRightAnchor(my.item, my.canSetWidth)
        my.usesTopAnchor = canSetTopAnchor(my.item, my.canSetHeight)
        my.usesBottomAnchor = canSetBottomAnchor(my.item, my.canSetHeight)

        if (my.usesLeftAnchor & my.usesRightAnchor)
            # Both horizontal anchors
            if !(my.item.x = 0)
>    $(my.indent)x: $(my.item.x)
            endif

            my.deltaWidth = my.item.x + my.item.fixedRight
            if (my.deltaWidth = 0)
>    $(my.indent)width: parent.width
            else
                if (my.deltaWidth > 0)
>    $(my.indent)width: parent.width - $(my.deltaWidth)
                else
>    $(my.indent)width: parent.width - ($(my.deltaWidth))
                endif
            endif
        elsif (my.usesRightAnchor)
            if (my.item.fixedRight = 0)
>    $(my.indent)x: parent.width - width
            else
                if (my.item.fixedRight > 0)
>    $(my.indent)x: parent.width - width - $(my.item.fixedRight)
                else
>    $(my.indent)x: parent.width - width - ($(my.item.fixedRight))
                endif
            endif

            if (my.canSetWidth)
>    $(my.indent)width: $(my.item.width) 
            endif
        else
            # Default (left anchor OR no horizontal anchor)
            if !(my.item.x = 0)
>    $(my.indent)x: $(my.item.x)
            endif
            if (my.canSetWidth)
>    $(my.indent)width: $(my.item.width) 
            endif
        endif

        if (my.usesTopAnchor & my.usesBottomAnchor)
            # Both vertical anchors
            if !(my.item.y = 0)
>    $(my.indent)y: $(my.item.y)
            endif

            my.deltaHeight = my.item.y + my.item.fixedBottom
            if (my.deltaHeight = 0)
>    $(my.indent)height: parent.height
            else
                if (my.deltaHeight > 0)
>    $(my.indent)height: parent.height - $(my.deltaHeight)
                else
>    $(my.indent)height: parent.height - ($(my.deltaHeight))
                endif
            endif
        elsif (my.usesBottomAnchor)
            if (my.item.fixedBottom = 0)
>    $(my.indent)y: parent.height - height
            else
                if (my.item.fixedBottom > 0)
>    $(my.indent)y: parent.height - height - $(my.item.fixedBottom)
                else
>    $(my.indent)y: parent.height - height - ($(my.item.fixedBottom))
                endif
            endif

            if (my.canSetHeight)
>    $(my.indent)height: $(my.item.height) 
            endif
        else
            # Default (top anchor or no vertical anchor)
            if !(my.item.y = 0)
>    $(my.indent)y: $(my.item.y)
            endif
            if (my.canSetHeight)
>    $(my.indent)height: $(my.item.height) 
            endif
        endif
    else
        # No anchor
        if !(my.item.x = 0)
>    $(my.indent)x: $(my.item.x)
        endif
        if !(my.item.y = 0)
>    $(my.indent)y: $(my.item.y)
        endif
        if (my.canSetWidth)
>    $(my.indent)width: $(my.item.width)
        endif
        if (my.canSetHeight)
>    $(my.indent)height: $(my.item.height)
        endif
    endif
endfunction renderItemPositioning_NoAnchors


function renderItemPositioning(item, level, canSetWidth, canSetHeight)
    my.indent = getIndent(my.level)
> 
    if (hasFixedLeft(my.item) & hasFixedRight(my.item) & hasFixedTop(my.item) & hasFixedBottom(my.item) & my.canSetWidth & my.canSetHeight)
        # All anchors (left, right, top, bottom)
        if ((my.item.x = 0) & (my.item.fixedRight = 0) & (my.item.y = 0) & (my.item.fixedBottom = 0))
>    $(my.indent)anchors.fill: parent
        else        
>    $(my.indent)anchors {
>        $(my.indent)fill: parent
            if !(my.item.x = 0)
>        $(my.indent)leftMargin: $(my.item.x)
            endif
            if !(my.item.fixedRight = 0)
>        $(my.indent)rightMargin: $(my.item.fixedRight)
            endif
            if !(my.item.y = 0)
>        $(my.indent)topMargin: $(my.item.y)
            endif
            if !(my.item.fixedBottom = 0)
>        $(my.indent)bottomMargin: $(my.item.fixedBottom)
            endif
>    $(my.indent)}
        endif
    elsif (hasFixedLeft(my.item) | hasFixedRight(my.item) | hasFixedTop(my.item) | hasFixedBottom(my.item))
        # At least one anchor
        my.usesLeftAnchor = canSetLeftAnchor(my.item, my.canSetWidth)
        my.usesRightAnchor = canSetRightAnchor(my.item, my.canSetWidth)
        my.usesTopAnchor = canSetTopAnchor(my.item, my.canSetHeight)
        my.usesBottomAnchor = canSetBottomAnchor(my.item, my.canSetHeight)
        if (my.usesLeftAnchor | my.usesRightAnchor | my.usesTopAnchor | my.usesBottomAnchor)
>    $(my.indent)anchors {
            if my.usesLeftAnchor   
>        $(my.indent)left: parent.left
                if !(my.item.x = 0)
>        $(my.indent)leftMargin: $(my.item.x)
                endif
            endif
            if my.usesRightAnchor
>        $(my.indent)right: parent.right
                if !(my.item.fixedRight = 0)
>        $(my.indent)rightMargin: $(my.item.fixedRight)
                endif
            endif
            if my.usesTopAnchor
>        $(my.indent)top: parent.top
                if !(my.item.y = 0)
>        $(my.indent)topMargin: $(my.item.y)            
                endif            
            endif
            if my.usesBottomAnchor
>        $(my.indent)bottom: parent.bottom
                if !(my.item.fixedBottom = 0)
>        $(my.indent)bottomMargin: $(my.item.fixedBottom)            
                endif            
            endif          
>    $(my.indent)}
>
        endif
        if (!my.usesLeftAnchor & !my.usesRightAnchor & !(my.item.x = 0))
>    $(my.indent)x: $(my.item.x) 
        endif
        if (!my.usesTopAnchor & !my.usesBottomAnchor & !(my.item.y = 0))
>    $(my.indent)y: $(my.item.y) 
        endif
        if (my.canSetWidth & needsToDefineWidth(my.item))
>    $(my.indent)width: $(my.item.width) 
        endif
        if (my.canSetHeight & needsToDefineHeight(my.item))
>    $(my.indent)height: $(my.item.height)        
        endif  
    else
        # No anchor
        
        if !(my.item.x = 0)
>    $(my.indent)x: $(my.item.x)
        endif
        if !(my.item.y = 0)
>    $(my.indent)y: $(my.item.y)
        endif
        if (my.canSetWidth)
>    $(my.indent)width: $(my.item.width)
        endif
        if (my.canSetHeight)
>    $(my.indent)height: $(my.item.height)
        endif
    endif
endfunction renderItemPositioning


#NB: Popup is not an item. It can not use anchors (except anchors.centerIn)
function renderItemPositioning_Popup(item, level, canSetWidth, canSetHeight)
    renderItemPositioning_NoAnchors(my.item, my.level, my.canSetWidth, my.canSetHeight)
endfunction


#NB: Special case - feedbacks should fill their parent
#    except if they explicitly defines a fixed width and/or fixed height
function renderItemPositioning_Feedback(item, level)
    if defined(global.sketch2qml_currentComponent)
        my.indent = getIndent(my.level)

        my.itemHasFixedWidth = hasFixedWidth(my.item)
        my.itemHasFixedHeight = hasFixedHeight(my.item)

        if (my.itemHasFixedWidth | my.itemHasFixedHeight)
            # Special case: at least one fixed dimension
>
>    $(my.indent)//Sketch warning: feedback does not fill its parent
>    $(my.indent)// => If this is not the expected behavior, remove fixed width and/or height in Sketch
>    $(my.indent)anchors {
            # Horizontal
            if (my.itemHasFixedWidth)
                if (hasFixedRight(my.item))
                    my.deltaRight = global.sketch2qml_currentComponent.width - my.item.width - my.item.x
>        $(my.indent)right: parent.right
                    if !(my.deltaRight = 0)
>        $(my.indent)rightMargin: $(my.deltaRight)
                    endif
                else
                    # We assume a left anchor
                    my.deltaLeft = my.item.x
>        $(my.indent)left: parent.left
                    if !(my.deltaLeft = 0)
>        $(my.indent)leftMargin: $(my.deltaLeft)
                    endif
                endif
            else
                # Fill horizontally
                my.deltaLeft = my.item.x
                my.deltaRight = global.sketch2qml_currentComponent.width - my.item.width - my.item.x

>        $(my.indent)left: parent.left
                if !(my.deltaLeft = 0)
>        $(my.indent)leftMargin: $(my.deltaLeft)
                endif
>        $(my.indent)right: parent.right
                if !(my.deltaRight = 0)
>        $(my.indent)rightMargin: $(my.deltaRight)
                endif
            endif

            # Vertical
            if (my.itemHasFixedHeight)
                if (hasFixedBottom(my.item))
                    my.deltaBottom = global.sketch2qml_currentComponent.height - my.item.height - my.item.y
>        $(my.indent)bottom: parent.bottom
                    if !(my.deltaBottom = 0)
>        $(my.indent)bottomMargin: $(my.deltaBottom)
                    endif
                else
                    # We assume a top anchor
                    my.deltaTop = my.item.y
>        $(my.indent)top: parent.top
                    if !(my.deltaTop = 0)
>        $(my.indent)topMargin: $(my.deltaTop)
                    endif
                endif
            else
                # Fill vertically
                my.deltaTop = my.item.y
                my.deltaBottom = global.sketch2qml_currentComponent.height - my.item.height - my.item.y

>        $(my.indent)top: parent.top
                if !(my.deltaTop = 0)
>        $(my.indent)topMargin: $(my.deltaTop)
                endif
>        $(my.indent)bottom: parent.bottom
                if !(my.deltaBottom = 0)
>        $(my.indent)bottomMargin: $(my.deltaBottom)
                endif
            endif
>    $(my.indent)}

            if (my.itemHasFixedWidth)
>
>    $(my.indent)width: $(my.item.width)
            endif
            if (my.itemHasFixedHeight)
>
>    $(my.indent)height: $(my.item.height)
            endif
        else
            # Default case: feedback will fill its parent with margins
    
            my.deltaLeft = my.item.x
            my.deltaRight = global.sketch2qml_currentComponent.width - my.item.width - my.item.x
            my.deltaTop = my.item.y
            my.deltaBottom = global.sketch2qml_currentComponent.height - my.item.height - my.item.y
>
            if ((my.deltaLeft = 0) & (my.deltaRight = 0) & (my.deltaTop = 0) & (my.deltaBottom = 0))
                # No margin
>    $(my.indent)anchors.fill: parent
            else
                # At least one margin
>    $(my.indent)anchors {
>        $(my.indent)fill: parent
                if !(my.deltaLeft = 0)
>        $(my.indent)leftMargin: $(my.deltaLeft)
                endif
                if !(my.deltaRight = 0)
>        $(my.indent)rightMargin: $(my.deltaRight)
                endif
                if !(my.deltaTop = 0)
>        $(my.indent)topMargin: $(my.deltaTop)
                endif
                if !(my.deltaBottom = 0)
>        $(my.indent)bottomMargin: $(my.deltaBottom)
                endif
>    $(my.indent)}
            endif
        endif
    else
        echo "Sketch2Qml warning: current component is not defined"
>    // Sketch2Qml warning: anchors may be invalid
        renderItemPositioning(my.item, my.level, 1, 1)
    endif
endfunction renderItemPositioning_Feedback


function renderTopAndLeftPadding(prefix, item, level)
    my.indent = getIndent(my.level)
    if !(my.item.x = 0)
>    $(my.indent)$(my.prefix)leftPadding: $(my.item.x)
    endif
    if !(my.item.y = 0)
>    $(my.indent)$(my.prefix)topPadding: $(my.item.y)
    endif
endfunction renderTopAndLeftPadding


function renderRightPadding(prefix, item, level, parentItem)
    my.value = my.parentItem.width - (my.item.x + my.item.width)
    if !(my.value = 0)
        my.indent = getIndent(my.level)
>    $(my.indent)$(my.prefix)rightPadding: $(my.value)
    endif
endfunction renderRightPadding


function renderBottomPadding(prefix, item, level, parentItem)
    my.value = my.parentItem.height - (my.item.y + my.item.height)
    if !(my.value = 0)
        my.indent = getIndent(my.level)
>    $(my.indent)$(my.prefix)bottomPadding: $(my.value)
    endif
endfunction renderBottomPadding


function renderPadding(prefix, item, level, parentItem)
    renderTopAndLeftPadding(my.prefix, my.item, my.level)
    renderRightPadding(my.prefix, my.item, my.level, my.parentItem)
    renderBottomPadding(my.prefix, my.item, my.level, my.parentItem)
endfunction renderPadding


function renderItemImplicitHeight(item, level)
    if !(my.item.height = 0)
        my.indent = getIndent(my.level)
>
>    $(my.indent)implicitHeight: $(my.item.height)
    endif
endfunction renderItemImplicitHeight


function renderItemImplicitSize(item, level)
    my.hasWidth = !(my.item.width = 0)
    my.hasHeight = !(my.item.height = 0)
    if (my.hasWidth | my.hasHeight)
        my.indent = getIndent(my.level)
>
        if my.hasWidth
>    $(my.indent)implicitWidth: $(my.item.width)
        endif

        if my.hasHeight
>    $(my.indent)implicitHeight: $(my.item.height)
        endif
    endif
endfunction renderItemImplicitSize


function renderItemTransformations(item, level)
    my.indent = getIndent(my.level)
    if defined(my.item.rotation)
>    
>    $(my.indent)rotation: $(my.item.rotation)
    endif
    if ((defined(my.item.flippedHorizontally) & my.item.flippedHorizontally) | (defined(my.item.flippedVertically) & my.item.flippedVertically))
>    
        if (defined(my.item.flippedHorizontally) & my.item.flippedHorizontally)    
>    $(my.indent)SketchFlipTransform.horizontally: true
        endif
        if (defined(my.item.flippedVertically) & my.item.flippedVertically)    
>    $(my.indent)SketchFlipTransform.vertically: true
        endif
    endif    
endfunction renderItemTransformations


function renderItemTransformations_Popup(item, level)
    my.indent = getIndent(my.level)
    if defined(my.item.rotation)
>    
>    $(my.indent)//rotation: $(my.item.rotation)
    endif
    if ((defined(my.item.flippedHorizontally) & my.item.flippedHorizontally) | (defined(my.item.flippedVertically) & my.item.flippedVertically))
>    
        if (defined(my.item.flippedHorizontally) & my.item.flippedHorizontally)    
>    $(my.indent)//SketchFlipTransform.horizontally: true
        endif
        if (defined(my.item.flippedVertically) & my.item.flippedVertically)    
>    $(my.indent)//SketchFlipTransform.vertically: true
        endif
    endif    
endfunction renderItemTransformations_Popup


function renderItemGenericProperties(item, level, canSetWidth, canSetHeight, canHaveAnchors)
    my.indent = getIndent(my.level)
    if (my.canHaveAnchors)
        renderItemPositioning(my.item, my.level, my.canSetWidth, my.canSetHeight)
    else
        renderItemPositioning_NoAnchors(my.item, my.level, my.canSetWidth, my.canSetHeight)
    endif
    renderItemTransformations(my.item, my.level)
    if (defined(my.item.hidden) & my.item.hidden)
>    $(my.indent)visible: false
>    $(my.indent)enabled: visible  
    endif
endfunction renderItemGenericProperties


function renderItemGenericProperties_SymbolInstance(item, level, canSetWidth, canSetHeight, canHaveAnchors)
    if (defined (my.item.symbolMasterParentType) & (string.length(my.item.symbolMasterParentType) > 0))
        my.type = "$(my.item.symbolMasterParentType:lower)"
        if (widgetTypeInheritsPopup(my.type))
            # Special case: popups don't have anchors (except centerIn)
            my.indent = getIndent(my.level)
            renderItemPositioning_Popup(my.item, my.level, my.canSetWidth, my.canSetHeight)
            renderItemTransformations_Popup(my.item, my.level)
            if (defined(my.item.hidden) & my.item.hidden)
>    $(my.indent)visible: false
>    $(my.indent)enabled: visible  
            endif
        else
            renderItemGenericProperties(my.item, my.level, my.canSetWidth, my.canSetHeight, my.canHaveAnchors)
        endif
    else
        renderItemGenericProperties(my.item, my.level, my.canSetWidth, my.canSetHeight, my.canHaveAnchors)
    endif
endfunction renderItemGenericProperties_SymbolInstance


function renderItemUserSetProperties(item, level)
    if count(my.item.property)
        my.indent = getIndent(my.level)
>        
        for my.item.property
>    $(my.indent)$(property.key): $(property.value)
        endfor
    endif
endfunction renderItemUserSetProperties


function renderItemChildren(appOrLibrary, item, level, isInLibrary)
    for my.item.item
>    
        iterateOnItem(my.appOrLibrary, item, my.level + 1, my.isInLibrary, "")
    endfor
endfunction renderItemChildren


function renderColorProperty(appOrLibrary, propertyName, value, level)
    my.indent = getIndent(my.level)
    if regexp.match("^swatch\\((.*)\\)$", my.value, swatchID)
        if (string.length(swatchID) > 0) 
            for my.appOrLibrary.swatch
                if swatch.id = swatchID
>    $(my.indent)$(my.propertyName): $(global.sketch2qml_appOrLibraryName)Theme.$(swatch.name:camel) 
                    return
                endif
            endfor
        endif
        # Named color not found: we use black by default to see something
>    $(my.indent)$(my.propertyName): "#000000" // Named color not found ($(my.value))
    else
>    $(my.indent)$(my.propertyName): "$(my.value)"
    endif
endfunction renderColorProperty


function sharedTextStyleExists(appOrLibrary, styleId)
    if (string.length(my.styleId) > 0) 
        for my.appOrLibrary.sharedtextstyle
            if sharedtextstyle.id = my.styleId           
                return 1
            endif
        endfor
    endif
    return 0
endfunction sharedTextStyleExists


function nullSharedTextStyleProperty(propertyName, level)
    my.indent = getIndent(my.level)
>    $(my.indent)$(my.propertyName): null
endfunction nullSharedTextStyleProperty


function renderSharedTextStyleProperty(appOrLibrary, propertyName, styleId, level)
    my.indent = getIndent(my.level)
    if (string.length(my.styleId) > 0) 
        for my.appOrLibrary.sharedtextstyle
            if sharedtextstyle.id = my.styleId
>    $(my.indent)$(my.propertyName): $(global.sketch2qml_appOrLibraryName)Theme.$(sharedtextstyle.name:camel) 
                return
            endif
        endfor
    endif
    nullSharedTextStyleProperty(my.propertyName, my.level)
endfunction renderSharedTextStyleProperty


function renderStringProperty(propertyName, value, level)
    my.indent = getIndent(my.level)
    if (string.length(my.value) > 0)
        if regexp.match("^\\\\u[0-9A-Fa-f]{4}$", my.value)
            # Special case: single unicode character
>    $(my.indent)$(my.propertyName): "$(my.value)"
        else
            # Generic case: translatable string
            my.validStringValue = string.replace(my.value, '"|\\"')
>    $(my.indent)$(my.propertyName): qsTr("$(my.validStringValue)")
        endif
    else
>    $(my.indent)$(my.propertyName): ""    
    endif
endfunction renderStringProperty


function renderFontProperty(propertyName, item, level) 
    my.basicProperties = (defined(my.item.fontFamily) | defined(my.item.fontSize) | defined(my.item.fontStyleName) | defined(my.item.fontWeight) | defined(my.item.fontStyle) | defined(my.item.kerning))
    my.decorationProperties = (defined(my.item.textUnderline) | defined(my.item.textStrikethrough) | defined(my.item.textTransform) | defined(my.item.fontVariant))

    if (my.basicProperties | my.decorationProperties)
        my.indent = getIndent(my.level)
>    $(my.indent)$(my.propertyName) {
        if defined(my.item.fontFamily)
>        $(my.indent)family: "$(my.item.fontFamily)"
        endif
        if defined(my.item.fontSize)
            my.pixelSize = math.floor(my.item.fontSize + 0.5)
>        $(my.indent)pixelSize: $(my.pixelSize)
        endif
        if defined (my.item.fontStyleName)
            if (!(defined (my.item.fontWeight)) | !(my.item.fontWeight = 5))
>        $(my.indent)styleName: "$(my.item.fontStyleName)"
            endif
        endif
#--------      
# NB: the following properties are provided for information purposes only
#     When 'styleName' is set, QML will match the font against 'styleName' 
#     instead of the font properties 'weight', 'bold' and 'italic'    
        if (defined (my.item.fontWeight) & !(my.item.fontWeight = 5))
            if (my.item.fontWeight <= 2)
>        $(my.indent)weight: Font.Thin
            elsif (my.item.fontWeight = 3)
>        $(my.indent)weight: Font.ExtraLight        
            elsif (my.item.fontWeight = 4)
>        $(my.indent)weight: Font.Light                
            elsif (my.item.fontWeight = 6)
>        $(my.indent)weight: Font.Medium           
            elsif ((my.item.fontWeight = 7) | (my.item.fontWeight = 8))
>        $(my.indent)weight: Font.DemiBold   
            elsif (my.item.fontWeight = 9)
>        $(my.indent)weight: Font.Bold   
            elsif ((my.item.fontWeight = 10) | (my.item.fontWeight = 11))
>        $(my.indent)weight: Font.ExtraBold  
            elsif (my.item.fontWeight >= 12)
>        $(my.indent)weight: Font.Black       
            endif 
        endif
        if (defined (my.item.fontStyle) & (my.item.fontStyle = "italic"))
>        $(my.indent)italic: true
        endif
 #-------   
        if defined (my.item.textUnderline)
>        $(my.indent)underline: true
        endif
        if defined (my.item.textStrikethrough)
>        $(my.indent)strikeout: true
        endif
#--------    
# NB: we assume that "textTransform" is more important than "textVariant"
        if (defined (my.item.textTransform) & !(my.item.textTransform = "none"))
            if (my.item.textTransform = "uppercase")
>        $(my.indent)capitalization: Font.AllUppercase       
            else
>        $(my.indent)capitalization: Font.AllLowercase    
            endif
        elsif (defined (my.item.fontVariant) & (my.item.fontVariant = "small-caps"))
>        $(my.indent)capitalization: Font.SmallCaps
        endif
# -------
        if (defined (my.item.kerning))
>        $(my.indent)letterSpacing: $(my.item.kerning)    
        endif       
>    $(my.indent)}
    endif
endfunction renderFontProperty


function renderTextAlignments(prefix, item, level, renderDefaultValues)
    my.indent = getIndent(my.level)
    if defined(my.item.alignment)
        if (my.item.alignment = "center")
>    $(my.indent)$(my.prefix)horizontalAlignment: Text.AlignHCenter
        elsif (my.item.alignment = "right")
>    $(my.indent)$(my.prefix)horizontalAlignment: Text.AlignRight
        elsif (my.item.alignment = "justify" | my.item.alignment = "justified")
            # NB: According to the documentation, the value is "justify" BUT Sketch 63.1 uses "justified" 
>    $(my.indent)$(my.prefix)horizontalAlignment: Text.AlignJustify
        elsif (my.renderDefaultValues)
>    $(my.indent)$(my.prefix)horizontalAlignment: Text.AlignLeft
        endif
    endif
    if defined(my.item.verticalAlignment)
        if (my.item.verticalAlignment = "center")
>    $(my.indent)$(my.prefix)verticalAlignment: Text.AlignVCenter
        elsif (my.item.verticalAlignment = "bottom")
>    $(my.indent)$(my.prefix)verticalAlignment: Text.AlignBottom
        elsif(my.renderDefaultValues)
>    $(my.indent)$(my.prefix)verticalAlignment: Text.AlignTop
        endif
    endif
endfunction renderTextAlignments


function renderTextLineHeight(prefix, item, level)
    if (defined (my.item.lineHeight))
        my.indent = getIndent(my.level)
>    $(my.indent)$(my.prefix)lineHeightMode: Text.FixedHeight
>    $(my.indent)$(my.prefix)lineHeight: $(my.item.lineHeight)  
    endif
endfunction renderTextLineHeight


function renderTextBehaviour(prefix, item, level)
    if defined(my.item.textBehaviour)
        my.indent = getIndent(my.level)
        if (my.item.textBehaviour = "autoHeight")
>    $(my.indent)$(my.prefix)textBehaviour: SketchTextBehaviour.AutoHeight
        elsif (my.item.textBehaviour = "fixedSize")
>    $(my.indent)$(my.prefix)textBehaviour: SketchTextBehaviour.FixedSize
        elsif !(my.item.textBehaviour = "autoWidth")
            echo "Unknown textBehaviour value: $(my.item.textBehaviour)"
        endif
    endif
endfunction renderTextBehaviour


function renderTextStyleProperties(appOrLibrary, prefix, isAnOverride, item, level, isInLibrary)
    my.indent = getIndent(my.level)
    if (defined(my.item.sharedStyleId) & sharedTextStyleExists(my.appOrLibrary, my.item.sharedStyleId))
        # We have a text style
        renderSharedTextStyleProperty(my.appOrLibrary, "$(my.prefix)textStyle", my.item.sharedStyleId, my.level)
        renderTextBehaviour(my.prefix, my.item, my.level)
        if isSharedStyleOutOfSync(my.item)
            # Our text uses a variant of this text style
            renderOpacity(my.prefix, my.item, my.level)
            if defined(my.item.textColor)
                renderColorProperty(my.appOrLibrary, "$(my.prefix)color", my.item.textColor, my.level)
            endif
            renderTextAlignments(my.prefix, my.item, my.level, 1)
            renderFontProperty("$(my.prefix)font", my.item, my.level)
            renderTextLineHeight(my.prefix, my.item, my.level)
        endif
    else
        # No text style or unknown text style => we apply raw properties
        if my.isAnOverride
            nullSharedTextStyleProperty("$(my.prefix)textStyle", my.level)
        endif

        renderTextBehaviour(my.prefix, my.item, my.level)
        renderOpacity(my.prefix, my.item, my.level)
        if defined(my.item.textColor)
            renderColorProperty(my.appOrLibrary, "$(my.prefix)color", my.item.textColor, my.level)
        endif
        renderTextAlignments(my.prefix, my.item, my.level, 0)
        renderFontProperty("$(my.prefix)font", my.item, my.level)
        renderTextLineHeight(my.prefix, my.item, my.level)
    endif
endfunction renderTextStyleProperties


function renderTextValue(item, level)
    for my.item.content
        if index () = 1
            renderStringProperty("text", content, my.level)
            last
        endif
    endfor
endfunction


function renderRadii(item, level)
    if count(my.item.point)
        my.indent = getIndent(my.level)
        for my.item.point
            if !(point.cornerRadius = 0)
                if (index() = 1)
>    $(my.indent)topLeftRadius: $(point.cornerRadius)
                elsif (index() = 2)
>    $(my.indent)topRightRadius: $(point.cornerRadius)   
                elsif (index() = 3)
>    $(my.indent)bottomRightRadius: $(point.cornerRadius)  
                elsif (index() = 4)
>    $(my.indent)bottomLeftRadius: $(point.cornerRadius)           
                endif
            endif
        endfor       
    endif
endfunction renderRadii


function renderInsets(item, level)
    my.indent = getIndent(my.level)

    if (defined (my.item.topInset) & !(my.item.topInset = 0))
>    $(my.indent)topInset: $(my.item.topInset)    
    endif
    if (defined (my.item.bottomInset) & !(my.item.bottomInset = 0))
>    $(my.indent)bottomInset: $(my.item.bottomInset)    
    endif
    if (defined (my.item.leftInset) & !(my.item.leftInset = 0))
>    $(my.indent)leftInset: $(my.item.leftInset)    
    endif
    if (defined (my.item.rightInset) & !(my.item.rightInset = 0))
>    $(my.indent)rightInset: $(my.item.rightInset)    
    endif
endfunction


function renderShapeFill(appOrLibrary, prefix, isAnOverride, item, level, isInLibrary)
    my.indent = getIndent(my.level)
    my.isSet = 0
    #NB: Parse list in reverse order (z-ordered list)
    my.count = count(my.item.fill)
    for my.item.fill by (my.count - item(fill))
        if ((fill.fillType = "Color") & fill.enabled & !my.isSet)
            my.isSet = 1
            renderColorProperty(my.appOrLibrary, "$(my.prefix)fillColor", fill.color, my.level)
            last
        endif
    endfor
    if !my.isSet
>    $(my.indent)$(my.prefix)fillColor: "transparent"    
    endif
endfunction renderShapeFill


function renderShapeBorder(appOrLibrary, prefix, isAnOverride, item, level, isInLibrary)
    my.indent = getIndent(my.level)
    my.isSet = 0
    #NB: Parse list in reverse order (z-ordered list)
    my.count = count(my.item.border)
    for my.item.border by (my.count - item(border))
        if ((border.fillType = "Color") & border.enabled & !my.isSet)
            my.isSet = 1
            renderColorProperty(my.appOrLibrary, "$(my.prefix)borderColor", border.color, my.level)
>    $(my.indent)$(my.prefix)borderWidth: $(border.thickness)
            if (border.position = "Inside")
>    $(my.indent)$(my.prefix)borderPosition: SketchBorderPosition.Inside           
            elsif (border.position = "Outside")
>    $(my.indent)$(my.prefix)borderPosition: SketchBorderPosition.Outside           
            else
>    $(my.indent)$(my.prefix)borderPosition: SketchBorderPosition.Center                      
            endif
            last
        endif
    endfor
    if !my.isSet
>    $(my.indent)$(my.prefix)borderColor: "transparent"
>    $(my.indent)$(my.prefix)borderWidth: 0
    endif
    if (defined (my.item.lineEnd))
        if (my.item.lineEnd = "Round")
>    $(my.indent)$(my.prefix)borderLineCap: Qt.RoundCap
        elsif (my.item.lineEnd = "Projecting")
>    $(my.indent)$(my.prefix)borderLineCap: Qt.SquareCap
        else
>    $(my.indent)$(my.prefix)borderLineCap: Qt.FlatCap
        endif
    elsif my.isAnOverride
        #NB: we don't know if our symbol uses a different value
>    $(my.indent)$(my.prefix)borderLineCap: Qt.FlatCap
    endif
    if (defined (my.item.lineJoin))
        if (my.item.lineJoin = "Round")
>    $(my.indent)$(my.prefix)borderLineJoin: Qt.RoundJoin
        elsif (my.item.lineJoin = "Bevel")
>    $(my.indent)$(my.prefix)borderLineJoin: Qt.BevelJoin
        else
>    $(my.indent)$(my.prefix)borderLineJoin: Qt.SvgMiterJoin
        endif
    elsif my.isAnOverride
        #NB: we don't know if our symbol uses a different value
>    $(my.indent)$(my.prefix)borderLineJoin: Qt.SvgMiterJoin
    endif
    if (defined (my.item.dashPattern) & string.length(my.item.dashPattern))
>    $(my.indent)$(my.prefix)borderDashPattern: "$(my.item.dashPattern)"
    elsif my.isAnOverride
        #NB: we don't know if our symbol uses a different value
>    $(my.indent)$(my.prefix)borderDashPattern: ""
    endif
endfunction renderShapeBorder


function renderClippingContainer_start(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
    my.subIndent = getIndent(1)

>$(my.indent)$(my.prefix)Item {
>$(my.indent)$(my.subIndent)id: $(my.item.name:camel)__clipContainer
    renderItemPositioning(my.item, my.level, 1, 1)
>
    return (my.level + 1)
endfunction renderClippingContainer_start


function renderClippingContainer_end(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
    my.subIndent = getIndent(1)

>$(my.indent)$(my.subIndent)Item {
>$(my.indent)$(my.subIndent)$(my.subIndent)id: $(my.item.name:camel)__clip
>
>$(my.indent)$(my.subIndent)$(my.subIndent)anchors.fill: parent
>
>$(my.indent)$(my.subIndent)$(my.subIndent)clip: true
>
>$(my.indent)$(my.subIndent)$(my.subIndent)rotation: $(my.item.name:camel).rotation
>
>$(my.indent)$(my.subIndent)$(my.subIndent)Item {
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)anchors.fill: parent
>
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)rotation: -parent.rotation
>
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)Item {
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)anchors {
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)fill: parent
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)leftMargin: -$(my.item.name:camel)__clipContainer.x
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)topMargin: -$(my.item.name:camel)__clipContainer.y
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)$(my.subIndent)}
>
    renderItemChildren(my.appOrLibrary, my.item, my.level, my.isInLibrary)
>$(my.indent)$(my.subIndent)$(my.subIndent)$(my.subIndent)}
>$(my.indent)$(my.subIndent)$(my.subIndent)}
>$(my.indent)$(my.subIndent)}
>$(my.indent)}
endfunction renderClippingContainer_end


#############################################################################
# QML renderers per type
#
function renderGroup(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)Item {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 1, 1, 1)
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level)
    renderItemChildren(my.appOrLibrary, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction renderGroup


function renderRow(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)Row {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 0, 1, 1) # Flexible width
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level)
    renderItemChildren(my.appOrLibrary, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction renderRow


function renderColumn(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)Column {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 1, 0, 1) # Flexible height
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level)
    renderItemChildren(my.appOrLibrary, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction renderColumn


function _renderRectangle(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)SketchRectangle {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 1, 1, 1)
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level) 
>
    renderRadii(my.item, my.level)

    renderShapeFill(my.appOrLibrary, "", 0, my.item, my.level, my.isInLibrary)
    renderShapeBorder(my.appOrLibrary, "", 0, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction _renderRectangle


function _renderRectangleAsClipMask(appOrLibrary, item, level, isInLibrary, prefix)
    my.itemLevel = renderClippingContainer_start(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    changePropertiesToForceAnchorsFillParent(item)
    _renderRectangle(my.appOrLibrary, my.item, my.itemLevel, my.isInLibrary, "")
    renderClippingContainer_end(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
endfunction _renderRectangleAsClipMask


function renderRectangle(appOrLibrary, item, level, isInLibrary, prefix)
    if (useAsMask(my.item) & count(my.item.item))
        _renderRectangleAsClipMask(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    else
        _renderRectangle(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    endif
endfunction renderRectangle


function _renderOval(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)SketchOval {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 1, 1, 1)
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level)

    renderShapeFill(my.appOrLibrary, "", 0, my.item, my.level, my.isInLibrary)
    renderShapeBorder(my.appOrLibrary, "", 0, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction _renderOval


function _renderOvalAsClipMask(appOrLibrary, item, level, isInLibrary, prefix)
    my.itemLevel = renderClippingContainer_start(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    changePropertiesToForceAnchorsFillParent(item)
    _renderOval(my.appOrLibrary, my.item, my.itemLevel, my.isInLibrary, "")
    renderClippingContainer_end(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
endfunction _renderOvalAsClipMask


function renderOval(appOrLibrary, item, level, isInLibrary, prefix)
    if (useAsMask(my.item) & count(my.item.item))
        _renderOvalAsClipMask(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    else
        _renderOval(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    endif
endfunction renderOval


function renderLine(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)SketchLine {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 1, 1, 1)
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level) 
>      
    for my.item.point
        if (index() = 1)
>    $(my.indent)startX: $(point.x)
>    $(my.indent)startY: $(point.y)
        elsif (index() = 2)
>    $(my.indent)endX: $(point.x)   
>    $(my.indent)endY: $(point.y)   
        endif
    endfor 

    renderShapeBorder(my.appOrLibrary, "", 0, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction renderLine


function _renderImage(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
  
    if itemIsResizable(my.item, 1, 1)
        # We use a BorderImage because we assume that our image will be resized (widgets, etc.)
>$(my.indent)$(my.prefix)SketchBorderImage {
    else
        if (my.isInLibrary & currentComponentHasLayerStyleOverrideForItem(my.item))
            # Layer rendered as an image that accepts an override of its layer style
            # => We need to use an advanced image item that can change its color
>$(my.indent)$(my.prefix)SketchImage {
        else
            # Real image or layer rendered as image that does not an overridable layer style
            # => We don't need to be able to change its color
>$(my.indent)$(my.prefix)SketchSimpleImage {
        endif
    endif
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, 1, 1, 1)
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level) 
>
    renderInsets(my.item, my.level)

    for my.item.export
        if index () = 1
            my.qrcUrl = getImageQrcUrl(export.file)
>    $(my.indent)source: "$(my.qrcUrl)"            
            if regexp.match ("(?i).*\.svg$", export.file)
>    $(my.indent)sourceSize {
>        $(my.indent)width: $(my.item.width)
>        $(my.indent)height: $(my.item.height)
>    $(my.indent)}                
            endif
            last
        endif
    endfor
>$(my.indent)}
endfunction _renderImage


function _renderImageAsClipMask(appOrLibrary, item, level, isInLibrary, prefix)
    my.itemLevel = renderClippingContainer_start(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    changePropertiesToForceAnchorsFillParent(item)
    _renderImage(my.appOrLibrary, my.item, my.itemLevel, my.isInLibrary, "")
    renderClippingContainer_end(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
endfunction _renderImageAsClipMask


function renderImage(appOrLibrary, item, level, isInLibrary, prefix)
    if (useAsMask(my.item) & count(my.item.item))
        _renderImageAsClipMask(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    else
        _renderImage(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
    endif
endfunction renderImage


function renderText(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
    my.canSetWidth = 1
    my.canSetHeight = 1
    if defined(my.item.textBehaviour)
        if (my.item.textBehaviour = "autoWidth")
            my.canSetWidth = 0
        elsif (my.item.textBehaviour = "autoHeight")
            my.canSetHeight = 0
        elsif !(my.item.textBehaviour = "fixedSize")
            echo "Unknown textBehaviour value: $(my.item.textBehaviour)"
        endif
    endif
>$(my.indent)$(my.prefix)SketchText {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties(my.item, my.level, my.canSetWidth, my.canSetHeight, 1)
    renderItemUserSetProperties(my.item, my.level) 
>
    renderTextStyleProperties(my.appOrLibrary, "", 0, my.item, my.level, my.isInLibrary)
>   
    renderTextValue(my.item, my.level)
>$(my.indent)}
endfunction renderText


function renderStates(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
    
    #the States node will not appear per se : we iterate directly from parent
    for my.item.item
>    
        iterateOnItem(my.appOrLibrary, item, my.level, my.isInLibrary, "")
    endfor
    
    #and now we generate States array based on subitems names
>$(my.indent)states: [
        for my.item.item
>    $(my.indent)State {
>        $(my.indent)name: "$(item.name)State"
>        $(my.indent)when: root.visible //TO BE EDITED
            #TODO: iterate on items again from parent to generate PropertyChanges blocks
            currentName = item.name
            for my.item.item
>        $(my.indent)PropertyChanges {
>            $(my.indent)target: $(item.name)
                if (item.name = currentName)
                    #echo("same " + currentName + " " + item.name)
>            $(my.indent)visible: true
                else
                    #echo ("different " + currentName + " " + item.name)
>            $(my.indent)visible: false
                endif
>        $(my.indent)}
            endfor
>    $(my.indent)}\
            if (last(item))
>
            else
>,
            endif
>
        endfor
>$(my.indent)]
endfunction renderStates


function renderSymbolOverrideAliasName(value)
    my.cleanValue = string.replace(my.value, ".|_")
    return my.cleanValue
endfunction renderSymbolOverrideAliasName


function renderSymbolOverridePropertyId(item, value)
    my.cleanValue = string.replace(my.value, ".|_")
    return "$(my.item.name:camel)_$(my.cleanValue)"
endfunction renderSymbolOverridePropertyId


function renderSymbolOverridePropertyShortName(value)
    if regexp.match("(.+)\\.([^\\.]+)$", my.value, leftPart, rightPart)
        return "$(rightPart)"
    else
        return "$(my.value)"
    endif
endfunction renderSymbolOverridePropertyShortName


function renderSymbolOverridePropertyName(value)
    if regexp.match("(.+)\\.([^\\.]+)$", my.value, leftPart, rightPart)
        return "$(leftPart).override_$(rightPart)"
    else
        return "override_$(my.value)"
    endif
endfunction renderSymbolOverridePropertyName

#NB: closeBlock is optional (true by default)
# Return true if we have an opened block, false otherwise
function renderOverride(appOrLibrary, item, override, level, isInLibrary, closeBlock) 
    if (!overrideIsDefault(my.override))
        my.indent = getIndent(my.level)

        if (isStringValueOverride(my.override))  
            renderStringProperty("$(my.override.on).text", my.override.value, my.level)
        elsif (isImageOverride(my.override))
            my.qrcUrl = getImageQrcUrl(my.override.value)
>    $(my.indent)$(my.override.on).source: "$(my.qrcUrl)"
        elsif (isTextStyleOverride(my.override))
            for my.override.textStyle
                if (index() = 1)
                    if (defined(textStyle.affectedLayerStyleIsOutOfSync) & textStyle.affectedLayerStyleIsOutOfSync)
>    $(my.indent)$(my.override.on).resetBindings: true
                    endif
                    renderTextStyleProperties(my.appOrLibrary, "$(my.override.on).", 1, textStyle, my.level, my.isInLibrary)
>
                    last
                endif
            endfor
        elsif (isLayerStyleOverride(my.override))
            for my.override.layerStyle
                if (index() = 1)
                    renderShapeFill(my.appOrLibrary, "$(my.override.on).", 1, layerStyle, my.level, my.isInLibrary)  
                    renderShapeBorder(my.appOrLibrary, "$(my.override.on).", 1, layerStyle, my.level, my.isInLibrary)
>
                    last
                endif
            endfor
        elsif (isSymbolOverride(my.override))
            if (string.length(my.override.newType) > 0)
>    $(my.indent)$(renderSymbolOverridePropertyName(my.override.on)): $(my.override.newType: Pascal) {
                if my.isInLibrary
>        $(my.indent)id: $(renderSymbolOverridePropertyId(my.item, my.override.on))
                endif
>        $(my.indent)objectName: "$(renderSymbolOverridePropertyShortName(my.override.on))"
                if count(my.override.override)
>
                    for my.override.override
                        renderOverride(my.appOrLibrary, my.item, override, my.level + 1, my.isInLibrary)
                    endfor
                endif

                if (!defined (my.closeBlock) | (my.closeBlock))
>    $(my.indent)}
>
                else
                    return 1
                endif
            else
>    $(my.indent)$(renderSymbolOverridePropertyName(my.override.on)): null
>
            endif
        endif
    endif

    return 0
endfunction renderOverride


function widgetLayerCompatibleWithAlias(layerName)
    #TODO: add extra rules (widgets)
    return !regexp.match("(item|popupItem)", my.layerName)
endfunction widgetLayerCompatibleWithAlias


function overrideMayNotBeSupported(path)
    #TODO: add extra rules (widgets)
    return regexp.match("^((.+)\.|)(item|popupItem)\.(.+)", my.path)
endfunction overrideMayNotBeSupported


function renderSymbolInstanceOverrides_Widget(appOrLibrary, item, level, isInLibrary, widgetType)
    my.indent = getIndent(my.level) 
    if count(my.item.override)
>       
        for my.item.override 
            if (!overrideIsDefault(override))
                if (isSymbolOverride(override) & widget_isExpectedLayer(my.widgetType, override.on))
                    # Widget layers
                    if (my.isInLibrary & (string.length(override.newType) > 0) & widgetLayerCompatibleWithAlias(override.on))
                        # NB: Aliases are strongly typed. We must overwrite our alias to 
                        #     allow overrides of its new properties (new class => new properties)
>    $(my.indent)property alias $(renderSymbolOverrideAliasName(override.on)): $(renderSymbolOverridePropertyId(my.item, override.on))
                    endif

                    if renderOverride(my.appOrLibrary, my.item, override, my.level, my.isInLibrary, 0)
                        # We need to close our block
  
                        if (regexp.match("combobox", "$(my.widgetType)") & regexp.match("popupItem", "$(override.on)"))
                            # Special case: item of a combobox
                            my.subIndent = getIndent(1) 
                            my.parentId = "$(my.item.name:camel)"
>    $(my.indent)$(my.subIndent)width: ListView.view.width
>    $(my.indent)$(my.subIndent)isFirst: (index === 0)
>    $(my.indent)$(my.subIndent)isLast: (index === (ListView.view.count - 1))
>    $(my.indent)$(my.subIndent)highlighted: ($(my.parentId).highlightedIndex === index)
>    $(my.indent)$(my.subIndent)//Qt 6.5.3 - QTBUG-112291: Array.isArray is unreliable
>    $(my.indent)$(my.subIndent)//TODO: Qt 6.8 - update the definition of our delegate see quickcontrols/basic/ComboBox.qml
>    $(my.indent)$(my.subIndent)selected: $(my.parentId).isCurrentIndex(index, $(my.parentId).valueRole ? (($(my.parentId).model instanceof Array) ? modelData[$(my.parentId).valueRole] : model[$(my.parentId).valueRole]) : modelData)
>    $(my.indent)$(my.subIndent)text: $(my.parentId).prettyPrint($(my.parentId).textRole ? (($(my.parentId).model instanceof Array) ? modelData[$(my.parentId).textRole] : model[$(my.parentId).textRole]) : modelData)
                        endif

                        # Close block
>    $(my.indent)}
>
                    endif
                else
                    # Other layers
                    if (overrideMayNotBeSupported(override.on))
>    $(my.indent)/* Override may not yet be supported
                        renderOverride(my.appOrLibrary, my.item, override, my.level, my.isInLibrary)
>    $(my.indent)*/
                    else
                        renderOverride(my.appOrLibrary, my.item, override, my.level, my.isInLibrary)
                    endif
                endif
            endif
        endfor
    endif
endfunction renderSymbolInstanceOverrides_Widget


function renderSymbolInstanceOverrides_Default(appOrLibrary, item, level, isInLibrary)
    my.indent = getIndent(my.level)
    if count(my.item.override)
>        
        for my.item.override
            if (!overrideIsDefault(override))
                if (my.isInLibrary & isSymbolOverride(override) & (string.length(override.newType) > 0))
                    # NB: Aliases are strongly typed. We must overwrite our alias to 
                    #     allow overrides of its new properties (new class => new properties)
>    $(my.indent)property alias $(renderSymbolOverrideAliasName(override.on)): $(renderSymbolOverridePropertyId(my.item, override.on))
                endif
                if (!isSymbolOverride(override) & overrideMayNotBeSupported(override.on))
>    $(my.indent)/* Override may not yet be supported
                    renderOverride(my.appOrLibrary, my.item, override, my.level, my.isInLibrary)
>    $(my.indent)*/
                else
                    renderOverride(my.appOrLibrary, my.item, override, my.level, my.isInLibrary)
                endif
            endif
        endfor
    endif
endfunction renderSymbolInstanceOverrides_Default


function renderSymbolInstanceOverrides(appOrLibrary, item, level, isInLibrary)
    if (defined (my.item.symbolMasterParentType) & (string.length(my.item.symbolMasterParentType) > 0))
        my.type = "$(my.item.symbolMasterParentType:lower)"
        if (isWidgetType(my.type))
            renderSymbolInstanceOverrides_Widget(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.type)
        else
            renderSymbolInstanceOverrides_Default(my.appOrLibrary, my.item, my.level, my.isInLibrary)
        endif
    else
        renderSymbolInstanceOverrides_Default(my.appOrLibrary, my.item, my.level, my.isInLibrary)
    endif
endfunction renderSymbolInstanceOverrides


function renderOverridableSymbolInstance(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)SketchSymbolInstance {
>    $(my.indent)id: overridable_$(my.item.name:camel)
    renderItemGenericProperties(my.item, my.level, 1, 1, 1)
    renderOpacity("", my.item, my.level)
>
>    $(my.indent)contentItem: $(my.item.type: Pascal) {
    renderIdAndObjectName(my.item, my.level + 1)
    renderItemUserSetProperties(my.item, my.level + 1) 
    renderSymbolInstanceOverrides(my.appOrLibrary, my.item, my.level + 1, my.isInLibrary)
>    $(my.indent)}
>$(my.indent)}
endfunction renderOverridableSymbolInstance


#NB: closeBlock is optional (true by default)
function renderNonOverridableSymbolInstance(appOrLibrary, item, level, isInLibrary, prefix, withSize, withAnchors, closeBlock)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)$(my.item.type: Pascal) {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties_SymbolInstance(my.item, my.level, my.withSize, my.withSize, my.withAnchors)
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level)
    renderSymbolInstanceOverrides(my.appOrLibrary, my.item, my.level, my.isInLibrary)

    if (!defined(my.closeBlock) | my.closeBlock)
>$(my.indent)}
    endif
endfunction renderNonOverridableSymbolInstance


function renderDefaultItem(appOrLibrary, item, level, isInLibrary, prefix)
    my.indent = getIndent(my.level)
>$(my.indent)$(my.prefix)$(my.item.type: Pascal) {
    renderIdAndObjectName(my.item, my.level)
    renderItemGenericProperties_SymbolInstance(my.item, my.level, 1, 1, 1) # We assume that we can set width and height, and anchors
    renderOpacity("", my.item, my.level)
    renderItemUserSetProperties(my.item, my.level)
    renderItemChildren(my.appOrLibrary, my.item, my.level, my.isInLibrary)
>$(my.indent)}
endfunction renderDefaultItem


#############################################################################
# Main functions for rendering of QML items
#
function iterateOnItem(appOrLibrary, item, level, isInLibrary, prefix)
    if defined (my.item.type)
        if (isRectangle(my.item))
            renderRectangle(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (isText(my.item))
            renderText(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
         elsif (isImage(my.item))
            renderImage(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (isGroup(my.item))
            renderGroup(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (isOval(my.item))
            renderOval(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (isLine(my.item))
            renderLine(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (my.item.type = "window")
            renderScreen(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (my.item.type = "Row")
            renderRow(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (my.item.type = "Column")
            renderColumn(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif (my.item.type = "States")
            renderStates(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        elsif isSymbolInstance(my.item)
            if (my.isInLibrary & currentComponentHasSymbolOverrideForItem(my.item))
                renderOverridableSymbolInstance(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
            else
                renderNonOverridableSymbolInstance(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix, 1, 1, 1)
            endif
        else
            # Default rendering for other types
            renderDefaultItem(my.appOrLibrary, my.item, my.level, my.isInLibrary, my.prefix)
        endif
    endif
endfunction iterateOnItem


#############################################################################
# Functions to render components (i.e. symbol masters)
#
function renderComponentProperties(component)
    # Custom properties
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases
    for my.component.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction renderComponentProperties


#NB: itemName is optional
function renderSymbolAsProperty(appOrLibrary, item, level, isInLibrary, propertyName, defineImplicitSize, closeBlock, itemName)
    if isSymbolInstance(my.item)
        my.indent = getIndent(my.level)
        my.subIndent = getIndent(1)

        if !defined(my.itemName)
            my.itemName = "$(my.item.name:camel)"
        endif

>    $(my.indent)$(my.propertyName): $(my.item.type: Pascal) {
>    $(my.indent)$(my.subIndent)id: $(my.itemName)
>    $(my.indent)$(my.subIndent)objectName: "$(my.itemName)"

        if (my.defineImplicitSize)
            renderItemImplicitSize(my.item, my.level + 1)
        endif

        renderOpacity("", my.item, my.level + 1)
        renderItemTransformations(my.item, my.level + 1)
        renderItemUserSetProperties(my.item, my.level + 1)
        renderSymbolInstanceOverrides(my.appOrLibrary, my.item, my.level + 1, my.isInLibrary)
        if my.closeBlock
>    $(my.indent)}
        endif
    endif
endfunction renderSymbolAsProperty


#NB: addPadding and propertyName are optional
function renderComponentProperty_Symbol(appOrLibrary, component, level, isInLibrary, itemName, addPadding, propertyName)
    my.indent = getIndent(my.level)

    if !defined(my.addPadding)
        # be default, we add padding data
        my.addPadding = 1
    endif

    if !defined(my.propertyName)
        my.renderAlias = 1
        my.propertyName = "$(my.itemName)"
    else
        # We use an existing property, we MUST not create an alias with the same name
        my.renderAlias = 0
    endif

    my.item = getChildNamed(my.component, my.itemName)?
    if (defined(my.item) & isSymbolInstance(my.item))
>
        if my.addPadding
            if my.renderAlias
                renderPadding("$(my.propertyName)_", my.item, my.level, my.component)
            else
                if (string.lexcmp(my.propertyName, "contentItem") = 0)
                    renderPadding("", my.item, my.level, my.component)
                else
                    echo "WARNING renderComponentProperty_Symbol: padding not yet implemented for $(my.propertyName)"
                endif
            endif
        endif

        if my.renderAlias
>    $(my.indent)property alias $(my.propertyName): $(my.itemName)
            renderSymbolAsProperty(my.appOrLibrary, my.item, my.level, my.isInLibrary, "override_$(my.propertyName)", 1, 1, my.itemName)
        else
            renderSymbolAsProperty(my.appOrLibrary, my.item, my.level, my.isInLibrary, "$(my.propertyName)", 1, 1, my.itemName)
        endif
    else
>
        if (defined(my.item) & !isSymbolInstance(my.item))
>    $(my.indent)// Sketch warning: layer $(my.itemName) is not a symbol instance, property $(my.propertyName) can not be rendered
            echo "Sketch2QML warning: layer $(my.itemName) is not a symbol instance, property $(my.propertyName) can not be rendered"
        endif

        if my.renderAlias
>    $(my.indent)property Item $(my.propertyName): null
        else
>    $(my.indent)$(my.propertyName): null
        endif
    endif
endfunction renderComponentProperty_Symbol


#NB: propertyName is optional
function renderComponentProperty_TextData(appOrLibrary, component, level, isInLibrary, itemName, exportTopLeftPadding, exportRightPadding, exportBottomPadding, propertyName)
    if !defined(my.propertyName)
        my.propertyName = "$(my.itemName)"
    endif

    my.item = getChildNamed(my.component, my.itemName)?
    if defined(my.item)
        my.indent = getIndent(my.level)
        my.subIndent = getIndent(1)

        if isText(my.item)
>
>    $(my.indent)$(my.propertyName): TextData {
            renderTextStyleProperties(my.appOrLibrary, "", 0, my.item, my.level + 1, my.isInLibrary)
            renderTextValue(my.item, my.level + 1)
            if (my.exportTopLeftPadding)
                renderTopAndLeftPadding("", my.item, my.level + 1)
            endif
        
            if (my.exportRightPadding)
                renderRightPadding("", my.item, my.level + 1, my.component)
            else
>    $(my.indent)$(my.subIndent)rightPadding: leftPadding
            endif
        
            if (my.exportBottomPadding)
                renderBottomPadding("", my.item, my.level + 1, my.component)
            else
>    $(my.indent)$(my.subIndent)bottomPadding: topPadding
            endif

>    $(my.indent)}
        else
>
>    $(my.indent)// Sketch warning: layer $(my.itemName) is not a text, property $(my.propertyName) can not be rendered
            echo "Sketch2QML warning: layer $(my.itemName) is not a text, property $(my.propertyName) can not be rendered"
        endif
    endif
endfunction renderComponentProperty_TextData


function renderComponentInstance_Message(component, itemName, level, canSetWidth, canSetHeight)
    my.item = getChildNamed(my.component, my.itemName)?
    if (defined(my.item))
        my.indent = getIndent(my.level)
        my.subIndent = getIndent(1)
>
>    $(my.indent)property alias $(my.itemName): $(my.itemName)
>    $(my.indent)$(my.item.type: Pascal) {
>    $(my.indent)$(my.subIndent)id: $(my.itemName)
        renderItemPositioning_Popup(my.item, my.level + 1, my.canSetWidth, my.canSetHeight)
>    $(my.indent)}
    endif
endfunction renderComponentInstance_Message


#NB: propertyName is optional
function renderComponentProperty_RectangleData(appOrLibrary, component, level, isInLibrary, itemName, exportTopLeftPadding, exportRightPadding, exportBottomPadding, propertyName)
    if !defined(my.propertyName)
        my.propertyName = "$(my.itemName)"
    endif
    
    my.item = getChildNamed(my.component, my.itemName)?
    if defined(my.item)
        my.indent = getIndent(my.level)
        my.subIndent = getIndent(1)

        my.isRectangle = isRectangle(my.item)
        my.isOval = isOval(my.item)

        if (my.isRectangle | my.isOval)
>
>    $(my.indent)$(my.propertyName): RectangleData {
            renderOpacity("", my.item, my.level + 1)

            if (my.isRectangle)
                renderRadii(my.item, my.level + 1)
            elsif (my.isOval)
                my.radiusX = my.item.width/2
                my.radiusY = my.item.height/2
                if (my.radiusX < my.radiusY)
                    my.radius = my.radiusX
                else
                    my.radius = my.radiusY
                endif
>    $(my.indent)$(my.subIndent)topLeftRadius: $(my.radius)
>    $(my.indent)$(my.subIndent)topRightRadius: $(my.radius)
>    $(my.indent)$(my.subIndent)bottomRightRadius: $(my.radius)
>    $(my.indent)$(my.subIndent)bottomLeftRadius: $(my.radius)
            endif

            if (my.exportTopLeftPadding)
                renderTopAndLeftPadding("", my.item, my.level + 1)
            endif

            if (my.exportRightPadding)
                renderRightPadding("", my.item, my.level + 1, my.component)
            else
>    $(my.indent)$(my.subIndent)rightPadding: leftPadding
            endif
        
            if (my.exportBottomPadding)
                renderBottomPadding("", my.item, my.level + 1, my.component)
            else
>    $(my.indent)$(my.subIndent)bottomPadding: topPadding
            endif
        
            renderShapeFill(my.appOrLibrary, "", 0, my.item, my.level + 1, my.isInLibrary)
            renderShapeBorder(my.appOrLibrary, "", 0, my.item, my.level + 1, my.isInLibrary)
>    $(my.indent)}
        else
>
>    $(my.indent)// Sketch warning: layer $(my.itemName) is not a rectangle (or oval), property $(my.propertyName) can not be rendered
            echo "Sketch2QML warning: layer $(my.itemName) is not a rectangle (or oval), property $(my.propertyName) can not be rendered"
        endif
    endif
endfunction renderComponentProperty_RectangleData


#NB: propertyName is optional
function renderComponentProperty_ImageData(appOrLibrary, component, level, isInLibrary, itemName, exportTopLeftPadding, exportRightPadding, exportBottomPadding, propertyName)
    if !defined(my.propertyName)
        my.propertyName = "$(my.itemName)"
    endif
    
    my.item = getChildNamed(my.component, my.itemName)?
    if defined(my.item)
        my.indent = getIndent(my.level) 
        my.subIndent = getIndent(1)

        if isImage(my.item)
            for my.item.export
                if index () = 1
                    my.qrcUrl = getImageQrcUrl(export.file)
>
>    $(my.indent)$(my.propertyName): ImageData {
>    $(my.indent)$(my.subIndent)source: "$(my.qrcUrl)"
                    renderInsets(my.item, my.level + 1)

                    if (my.exportTopLeftPadding)
                        renderTopAndLeftPadding("", my.item, my.level + 1)
                    endif

                    if (my.exportRightPadding)
                        renderRightPadding("", my.item, my.level + 1, my.component)
                    else
>    $(my.indent)$(my.subIndent)rightPadding: leftPadding
                    endif

                    if (my.exportBottomPadding)
                        renderBottomPadding("", my.item, my.level + 1, my.component)
                    else
>    $(my.indent)$(my.subIndent)bottomPadding: topPadding
                    endif

>    $(my.indent)}
                    last
                endif
            endfor
        else
>
>    $(my.indent)// Sketch warning: layer $(my.itemName) is not an image, property $(my.propertyName) can not be rendered
            echo "Sketch2QML warning: layer $(my.itemName) is not an image, property $(my.propertyName) can not be rendered"
        endif
    endif
endfunction renderComponentProperty_ImageData


function renderComponent_StatePartAlias(component, level, qmlItemId, partName)
    my.indent = getIndent(my.level)

    my.part = getChildNamed(my.component, my.partName)?
    if defined(my.item)
        my.type = bestType(my.part)
        if (my.type = "symbol")
>$(my.indent)property alias override_$(my.partName): $(my.qmlItemId)..$(my.partName)
        else
>$(my.indent)property alias $(my.partName): $(my.qmlItemId).$(my.partName)
        endif
    endif
endfunction renderComponent_StatePartAlias


function renderComponent_FeedbackAlias(component, level, itemName)
    my.indent = getIndent(my.level)

    my.feedback = getChildNamed(my.component, my.itemName)?
    if defined(my.feedback)
        my.type = bestType(my.feedback)
        my.qmlItemId = "$(my.itemName)Item"
        if (my.type = "symbol")
>$(my.indent)property alias $(my.itemName): $(my.itemName)
>$(my.indent)property alias override_$(my.itemName): $(my.qmlItemId).contentItem
        else
>$(my.indent)property alias $(my.itemName): $(my.qmlItemId).partData
        endif
    endif
endfunction renderComponent_FeedbackAlias


# NB: visibleValue and zValue are optional
function renderComponent_Feedback(appOrLibrary, component, level, isInLibrary, itemName, visibleValue, zValue)
    my.indent = getIndent(my.level)
    my.subIndent = getIndent(1)

    my.feedback = getChildNamed(my.component, my.itemName)?
    if defined(my.feedback)
>
        my.type = bestType(my.feedback)
        my.qmlItemId = "$(my.itemName)Item"

        if (my.type = "symbol")
>$(my.indent)SketchControlSymbolPart {
>$(my.indent)$(my.subIndent)id: $(my.qmlItemId)
            renderItemPositioning_Feedback(my.feedback, my.level)
>

            if defined(my.visibleValue)
>$(my.indent)$(my.subIndent)visible: $(my.visibleValue)
            endif

            if defined(my.zValue)
>$(my.indent)$(my.subIndent)z: $(my.zValue)
            endif

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, my.level, my.isInLibrary, my.itemName, 0, "contentItem")
>$(my.indent)}
        elsif (my.type = "image")
>$(my.indent)SketchControlImagePart {
>$(my.indent)$(my.subIndent)id: $(my.qmlItemId)
            renderItemPositioning_Feedback(my.feedback, my.level)
>
            if defined(my.visibleValue)
>$(my.indent)$(my.subIndent)visible: $(my.visibleValue)
            endif
            
            if defined(my.zValue)
>$(my.indent)$(my.subIndent)z: $(my.zValue)
            endif
            
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, my.level, my.isInLibrary, my.itemName, 0, 0, 0, "partData")
>$(my.indent)}
        else
>$(my.indent)SketchControlMaterialPart {
>$(my.indent)$(my.subIndent)id: $(my.qmlItemId)
            renderItemPositioning_Feedback(my.feedback, my.level)
>
            if defined(my.visibleValue)
>$(my.indent)$(my.subIndent)visible: $(my.visibleValue)
            endif

            if defined(my.zValue)
>$(my.indent)$(my.subIndent)z: $(my.zValue)
            endif

            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, my.level, my.isInLibrary, my.itemName, 0, 0, 0, "partData")
>$(my.indent)}
        endif

        return 1
    else
        # Feedback layer does not exist
        return 0
    endif
endfunction renderComponent_Feedback


function widget_isExpectedLayer(widgetType, name)
    if (my.widgetType = "button")
        return button_isExpectedLayer(my.name)
    elsif (my.widgetType = "checkbox")
        return checkbox_isExpectedLayer(my.name)
    elsif (my.widgetType = "combobox")
        return combobox_isExpectedLayer(my.name)
    elsif (my.widgetType = "comboboxitem")
        return comboboxitem_isExpectedLayer(my.name)
    elsif (my.widgetType = "list")
        return list_isExpectedLayer(my.name)
    elsif (my.widgetType = "menu")
        return menu_isExpectedLayer(my.name)
    elsif (my.widgetType = "menuitem")
        return menuitem_isExpectedLayer(my.name)
    elsif (my.widgetType = "message")
        return message_isExpectedLayer(my.name)
    elsif (my.widgetType = "popup")
        return popup_isExpectedLayer(my.name)
    elsif (my.widgetType = "radiobutton")
        return radiobutton_isExpectedLayer(my.name)
    elsif (my.widgetType = "scrollbar")
        return scrollbar_isExpectedLayer(my.name)
    elsif (my.widgetType = "scrollview")
        return scrollview_isExpectedLayer(my.name)
    elsif (my.widgetType = "tabbutton")
        return tabbutton_isExpectedLayer(my.name)
    elsif (my.widgetType = "textfield")
        return textfield_isExpectedLayer(my.name)
    elsif (my.widgetType = "togglebutton")
        return togglebutton_isExpectedLayer(my.name)
    elsif (my.widgetType = "tooltip")
        return tooltip_isExpectedLayer(my.name)
    else
        return 0
    endif
    #TODO: add extra widgets
endfunction widget_isExpectedLayer


function bestType(item)
    if defined(my.item)
        if isImage(my.item)
            return "image"
        elsif (isRectangle(my.item) | isOval(my.item))
            return "material"
        endif
    endif    

    # It's easier to implement a missing part with an empty symbol
    return "symbol"
endfunction bestType


function bestIconType(item)
    if defined(my.item)
        if isImage(my.item)
            return "image"
        elsif isText(my.item)
            return "text"
        else
            return "symbol"
        endif
    endif    

    # It's easier to implement a missing icon with an empty image's source
    return "image"
endfunction bestIconType


function bestIconType_legacy(item)
    if defined(my.item)
        if isImage(my.item)
            return "image"
        else
            return "symbol"
        endif
    endif    

    # It's easier to implement a missing icon with an empty image's source
    return "image"
endfunction bestIconType_legacy


function focusFeedbackZ(isAbove)
    if (my.isAbove)
        return 2
    else
        return -2
    endif
endfunction focusFeedbackZ


function isAbstactButtonType(type)
    # QtQuick.Controls that inherits AbstractButton
    #TODO: add extra widgets
    return regexp.match("^(button|(radio|tab|toggle)button|checkbox|menuitem)$", my.type)
endfunction isAbstactButtonType


function isWidgetType(type)
    #TODO: add extra widgets
    return regexp.match("^(button(|group)|(radio|toggle)button|checkbox|combobox(|item)|list|menu(|item)|message|popup|scroll(bar|view)|stack|swipe|tab(bar|button)|text(area|field)|tooltip)$", my.type)
endfunction isWidgetType


function widgetTypeInheritsPopup(type)
    #TODO: add extra widgets
    return regexp.match("^(menu|message|popup|tooltip)$", my.type)
endfunction widgetTypeInheritsPopup


############### Special case: Button ###############


function button_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled)Background$", my.usedName) 
endfunction button_isBackgroundLayer


function button_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled)Text$", my.usedName) 
endfunction button_isTextLayer


function button_isIconLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled)Icon$", my.usedName) 
endfunction button_isIconLayer


function button_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(focus|hover|press)Feedback$", my.usedName)
endfunction button_isFeedbackLayer


function button_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press)Feedback$", my.usedName)
endfunction button_isSpecialFeedback


function button_isOtherLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^menu$", my.usedName) 
endfunction button_isOtherLayer


function button_isExpectedLayer(name)
    return (button_isBackgroundLayer(my.name) | button_isTextLayer(my.name) | button_isIconLayer(my.name) | button_isFeedbackLayer(my.name) | button_isOtherLayer(my.name))
endfunction button_isExpectedLayer


function button_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif

    return my.item
endfunction button_itemWithStates


function button_background(component)
    return button_itemWithStates(my.component, "Background")
endfunction button_background


function button_icon(component)
    return button_itemWithStates(my.component, "Icon")
endfunction button_icon


function button_text(component)
    return button_itemWithStates(my.component, "Text")
endfunction button_text


function button_isBackgroundOrFeedbackLayer(name)
    return (button_isBackgroundLayer(my.name) | button_isFeedbackLayer(my.name))
endfunction button_isBackgroundOrFeedbackLayer


function button_itemIsAboveBackgroundLayers(component, targetName)
    my.targetItemIndex = -1
    my.lastBackgroundOrContentIndex = -1
    for my.component.item where button_isBackgroundOrFeedbackLayer(name)
        my.currentIndex = index()
        if (string.lexcmp("$(name:camel)", my.targetName) = 0)
            my.targetItemIndex = my.currentIndex 
        elsif (my.currentIndex > my.lastBackgroundOrContentIndex)
            my.lastBackgroundOrContentIndex = my.currentIndex
        endif
    endfor

    return (my.targetItemIndex > my.lastBackgroundOrContentIndex)
endfunction button_itemIsAboveBackgroundLayers


function renderComponent_Button(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchButton {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !button_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "focusFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Focus feedback
    my.focusFeedbackIsAbove = button_itemIsAboveBackgroundLayers(my.component, "focusFeedback")
    if !renderComponent_Feedback(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusFeedback", "root.visualFocus", focusFeedbackZ(my.focusFeedbackIsAbove))
>
>    activeFocusOnTab: false
>
    endif

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = button_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background
    my.background = button_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>
>    background: SketchButtonSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            elsif (my.backgroundType = "image")
>
>    background: SketchButtonImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
            else
>
>    background: SketchButtonMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>
            endif
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState")
>    }
        elsif (my.hasBackground)
>
            if (my.backgroundType = "symbol")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_hoveredBackground: backgroundItem.override_hoveredBackground
>    property alias override_pressedBackground: backgroundItem.override_pressedBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground
>
>    flat: (override_defaultBackground === null)
> 
>    background: SketchButtonSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>
>    flat: (defaultBackground === null) || (defaultBackground.source === "")
>
>    background: SketchButtonImageBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>    }
            else
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>
>    property real backgroundRadius: (backgroundItem.partData ? backgroundItem.partData.radius : 0)
>    property real backgroundTopLeftRadius: (backgroundItem.partData ? backgroundItem.partData.topLeftRadius : 0)
>    property real backgroundTopRightRadius: (backgroundItem.partData ? backgroundItem.partData.topRightRadius : 0)
>    property real backgroundBottomRightRadius: (backgroundItem.partData ? backgroundItem.partData.bottomRightRadius : 0)
>    property real backgroundBottomLeftRadius: (backgroundItem.partData ? backgroundItem.partData.bottomLeftRadius : 0)
>
>    flat: (defaultBackground === null)
>
>    background: SketchButtonMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>    }
            endif
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif


    # Text and/or icon ?
    my.text = button_text(my.component)?
    my.hasText = defined(my.text)
    my.icon = button_icon(my.component)?
    my.hasIcon = defined(my.icon)
    my.hasTextAndIcon = my.hasText & my.hasIcon

    if (my.hasText | my.hasIcon)
        my.iconType = ""

        # Icon properties
        if (my.hasIcon)
            my.iconType = bestIconType(my.icon)

            if (my.iconType = "symbol")
>
>    property alias defaultIcon: iconItem.defaultIcon
>    property alias hoveredIcon: iconItem.hoveredIcon
>    property alias pressedIcon: iconItem.pressedIcon
>    property alias disabledIcon: iconItem.disabledIcon
>
>    property alias override_defaultIcon: iconItem.override_defaultIcon
>    property alias override_hoveredIcon: iconItem.override_hoveredIcon
>    property alias override_pressedIcon: iconItem.override_pressedIcon
>    property alias override_disabledIcon: iconItem.override_disabledIcon
            elsif (my.iconType = "text")
>
>    property alias iconItem: iconItem
>    property alias defaultIcon: iconItem.defaultText
>    property alias hoveredIcon: iconItem.hoveredText
>    property alias pressedIcon: iconItem.pressedText
>    property alias disabledIcon: iconItem.disabledText
            else
                # Image
>
>    property alias defaultIcon: iconItem.defaultIcon
>    property alias hoveredIcon: iconItem.hoveredIcon
>    property alias pressedIcon: iconItem.pressedIcon
>    property alias disabledIcon: iconItem.disabledIcon
            endif
        endif

        # Text properties
        if (my.hasText)
>
>    property alias defaultText: textItem.defaultText
>    property alias hoveredText: textItem.hoveredText
>    property alias pressedText: textItem.pressedText
>    property alias disabledText: textItem.disabledText
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
            if (my.hasTextAndIcon)
                #  Text and icon: we don't use padding to define margins of contentItem
>    leftPadding: 0
>    rightPadding: 0
>    topPadding: 0
>    bottomPadding: 0
            else
                # Text only
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
            endif
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
        endif


        if (my.hasTextAndIcon)
            # Both text and icon
>
>    contentItem: Item {
>    $(my.subIndent)implicitWidth: textItem.implicitWidth
>    $(my.subIndent)implicitHeight: textItem.implicitHeight

            # Icon
            if (my.iconType = "symbol")
>
>    $(my.subIndent)SketchButtonVectorIcon {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0)
>    $(my.subIndent)}
            elsif (my.iconType = "text")
>
>    $(my.subIndent)SketchButtonText {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0, 0, 0, "defaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0, "hoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0, "pressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0, "disabledText")
>    $(my.subIndent)}
            else
>
>    $(my.subIndent)SketchButtonIcon {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0)
>    $(my.subIndent)}
            endif


            # Text
>
>    $(my.subIndent)SketchButtonText {
>    $(my.subIndent)$(my.subIndent)id: textItem
>    $(my.subIndent)$(my.subIndent)control: root
>
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
>
>    $(my.subIndent)$(my.subIndent)leftPadding: (textData ? textData.leftPadding : 0)
>    $(my.subIndent)$(my.subIndent)rightPadding: (textData ? textData.rightPadding : 0)
>    $(my.subIndent)$(my.subIndent)topPadding: (textData ? textData.topPadding : 0)
>    $(my.subIndent)$(my.subIndent)bottomPadding: (textData ? textData.bottomPadding : 0)
>
>    $(my.subIndent)$(my.subIndent)font: root.font
>    $(my.subIndent)$(my.subIndent)text: root.text
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledText", 1, 1, 1)
>    $(my.subIndent)}
>    }
        elsif (my.hasIcon)
            # Icon only
            if (my.iconType = "symbol")
>
>    contentItem: SketchButtonVectorIcon {
>    $(my.subIndent)id: iconItem
>    $(my.subIndent)control: root
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIcon")
>    }
            elsif (my.iconType = "text")
>
>    contentItem: Item {
>    $(my.subIndent)implicitWidth: iconItem.implicitWidth
>    $(my.subIndent)implicitHeight: iconItem.implicitHeight
>
>    $(my.subIndent)$(my.subIndent)SketchButtonText {
>    $(my.subIndent)$(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)$(my.subIndent)control: root
>
>    $(my.subIndent)$(my.subIndent)$(my.subIndent)anchors.centerIn: parent
>
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 1, 1, 1, "defaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 1, 1, 1, "hoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 1, 1, 1, "pressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 1, 1, 1, "disabledText")
>    $(my.subIndent)$(my.subIndent)}
>    }
            else
>
>    contentItem: SketchButtonIcon {
>    $(my.subIndent)id: iconItem
>    $(my.subIndent)control: root
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIcon", 0, 0, 0)
>    }
            endif
        else
            # Text only
>
>    contentItem: SketchButtonText {
>    $(my.subIndent)id: textItem
>    $(my.subIndent)control: root
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledText", 1, 1, 1)
>    }
        endif
    endif


    # Menu
    my.menu = getChildNamed(my.component, "menu")?
    if defined(my.menu)
        if isSymbolInstance(my.menu)
>
>    property alias menu: menu
>
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.menu, 1, my.isInLibrary, "", 0, 1, 1)
>
>    onClicked: menu.open();
>
>    onVisibleChanged: {
>        if (!visible)
>            menu.close();
>    }
>
        else
            echo "Sketch2Qml warning: Button $(my.component.name) contains a child named 'menu' that is not a symbol instance"
        endif
    endif


    # Extra children
    for my.component.item where !button_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_Button


############### Special case: ButtonGroup ###############


function renderComponent_ButtonGroup(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
        # No need to import QtQuick.Templates
    else
        importQtQuickTemplates()
    endif
    importExtraQmlModules()
>
>
>Item {
>   id: root
    #NB: custom item - we need an implicit size
    renderItemImplicitSize(my.component, 0)
>
>    property alias buttonGroup: buttonGroup
>
    renderItemUserSetProperties(my.component, 0)
>
    #NB: we assume that instances defined inside a buttongroup could be any type of item
    for my.component.item
        if isSymbolInstance(item)
            generatePropertyAliasesForNonOverridableSymbolInstance(item, "", "")
        else
            generatePropertyAliases(item, "", "")
        endif
    endfor

>
>    ButtonGroup {
>    $(my.subIndent)id: buttonGroup
     if (defined(global.sketch2qml_useQt5) & global.sketch2qml_useQt5)
>    $(my.subIndent)buttons: root.children
     else
        # Starting from Qt 6.8, we must ensure that 'buttons' only contains AbstractButtons
        # Otherwise, it triggers QML warnings (Cannot append XXXX to a QML list of QQuickAbstractButton*)
>    $(my.subIndent)buttons: root.children.filter((child) => (child instanceof T.AbstractButton))
     endif
>    }
>

    # All children
    my.isFirstAbstractButton = 1
    for my.component.item
>
        if isSymbolInstance(item)
            if (my.isFirstAbstractButton)
                if (defined (item.symbolMasterParentType) & (string.length(item.symbolMasterParentType) > 0))
                    my.instanceType = "$(item.symbolMasterParentType:lower)"
                    renderNonOverridableSymbolInstance(my.appOrLibrary, item, 1, my.isInLibrary, "", 1, 1, 0)
                    if (my.isFirstAbstractButton & isAbstactButtonType(my.instanceType))
                        my.isFirstAbstractButton = 0
>
>    $(my.subIndent)checked: true
                    endif
>    }
                else
                    renderNonOverridableSymbolInstance(my.appOrLibrary, item, 1, my.isInLibrary, "", 1, 1, 1)
                endif
            else
                renderNonOverridableSymbolInstance(my.appOrLibrary, item, 1, my.isInLibrary, "", 1, 1, 1)
            endif
        else
            iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
        endif
    endfor
>}
endfunction renderComponent_ButtonGroup


############### Special case: Checkbox ###############


function checkbox_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|((checked|partiallyChecked)(Default|Hovered|Pressed|Disabled)))Background$", my.usedName) 
endfunction checkbox_isBackgroundLayer


function checkbox_isIndicatorLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|((checked|partiallyChecked)(Default|Hovered|Pressed|Disabled)))Indicator$", my.usedName) 
endfunction checkbox_isIndicatorLayer


function checkbox_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|((checked|partiallyChecked)(Default|Hovered|Pressed|Disabled)))Text$", my.usedName) 
endfunction checkbox_isTextLayer


function checkbox_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(focus|hover|press)Feedback$", my.usedName)
endfunction checkbox_isFeedbackLayer


function checkbox_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press)Feedback$", my.usedName)
endfunction checkbox_isSpecialFeedback


function checkbox_isExpectedLayer(name)
    return (checkbox_isBackgroundLayer(my.name) | checkbox_isIndicatorLayer(my.name) | checkbox_isTextLayer(my.name) | checkbox_isFeedbackLayer(my.name))
endfunction checkbox_isExpectedLayer


function checkbox_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif

    if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedDefault$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedHovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedPressed$(my.suffix)")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "checkedDisabled$(my.suffix)")?
    endif

    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedDefault$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedHovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedPressed$(my.suffix)")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "partiallyCheckedDisabled$(my.suffix)")?
    endif

    return my.item
endfunction checkbox_itemWithStates


function checkbox_background(component)
    return checkbox_itemWithStates(my.component, "Background")
endfunction checkbox_background


function checkbox_indicator(component)
    return checkbox_itemWithStates(my.component, "Indicator")
endfunction checkbox_indicator


function checkbox_isTristate(component)
    my.item = getChildNamed(my.component, "partiallyCheckedDefaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedHoveredBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedPressedBackground")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "partiallyCheckedDisabledBackground")?
    endif

    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedDefaultIndicator")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedHoveredIndicator")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedPressedIndicator")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "partiallyCheckedDisabledIndicator")?
    endif

    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedDefaultText")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedHoveredText")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "partiallyCheckedPressedText")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "partiallyCheckedDisabledText")?
    endif

    return defined(my.item) 
endfunction checkbox_isTristate


function checkbox_hasLabel(component)
    my.item = checkbox_itemWithStates(my.component, "Text")?
    return defined(my.item)
endfunction checkbox_hasLabel


function checkbox_isBackgroundOrFeedbackLayer(name)
    return (checkbox_isBackgroundLayer(my.name) | checkbox_isFeedbackLayer(my.name))
endfunction checkbox_isBackgroundOrFeedbackLayer


function checkbox_itemIsAboveBackgroundLayers(component, targetName)
    my.targetItemIndex = -1
    my.lastBackgroundOrContentIndex = -1
    for my.component.item where checkbox_isBackgroundOrFeedbackLayer(name)
        my.currentIndex = index()
        if (string.lexcmp("$(name:camel)", my.targetName) = 0)
            my.targetItemIndex = my.currentIndex 
        elsif (my.currentIndex > my.lastBackgroundOrContentIndex)
            my.lastBackgroundOrContentIndex = my.currentIndex
        endif
    endfor

    return (my.targetItemIndex > my.lastBackgroundOrContentIndex)
endfunction checkbox_itemIsAboveBackgroundLayers


function renderComponent_CheckBox(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
    
>
>
>SketchCheckBox {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !checkbox_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    my.isTristate = checkbox_isTristate(my.component)?
    if (my.isTristate)
>   tristate : true
    endif

    renderComponent_FeedbackAlias(my.component, 1, "focusFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Focus feedback
    my.focusFeedbackIsAbove = checkbox_itemIsAboveBackgroundLayers(my.component, "focusFeedback")
    if !renderComponent_Feedback(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusFeedback", "root.visualFocus", focusFeedbackZ(my.focusFeedbackIsAbove))
>
>    activeFocusOnTab: false
>
    endif

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = button_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background
    my.background = checkbox_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            #
            # UI based on feedback layers
            #
            if (my.backgroundType = "symbol")
>
>    background: SketchCheckBoxSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
                if (my.isTristate)
                    renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultBackground")
                    renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledBackground")
                endif

            elsif (my.backgroundType = "image")
>
>    background: SketchCheckBoxImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
                if (my.isTristate)
                    renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultBackground", 1, 1, 1)
                    renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledBackground", 1, 1, 1)
                endif
            
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
>
            else
>    background: SketchCheckBoxMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
                if (my.isTristate)
                    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultBackground", 1, 1, 1)
                    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledBackground", 1, 1, 1)
                endif

            endif

        renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState || root.checkedHoveredState || root.partiallyCheckedHoveredState")
        renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState || root.checkedPressedState || root.partiallyCheckedPressedState")
>    }
        else
            #
            # UI based on state layers (one layer per state)
            #
>
            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_hoveredBackground: backgroundItem.override_hoveredBackground
>    property alias override_pressedBackground: backgroundItem.override_pressedBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground
>    property alias override_checkedDefaultBackground: backgroundItem.override_checkedDefaultBackground
>    property alias override_checkedHoveredBackground: backgroundItem.override_checkedHoveredBackground
>    property alias override_checkedPressedBackground: backgroundItem.override_checkedPressedBackground
>    property alias override_checkedDisabledBackground: backgroundItem.override_checkedDisabledBackground
                if (my.isTristate)
>    property alias override_partiallyCheckedDefaultBackground: backgroundItem.override_partiallyCheckedDefaultBackground
>    property alias override_partiallyCheckedHoveredBackground: backgroundItem.override_partiallyCheckedHoveredBackground
>    property alias override_partiallyCheckedPressedBackground: backgroundItem.override_partiallyCheckedPressedBackground
>    property alias override_partiallyCheckedDisabledBackground: backgroundItem.override_partiallyCheckedDisabledBackground
                endif
>
>    background: SketchCheckBoxSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
                if (my.isTristate)
                    renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultBackground")
                    renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredBackground")
                    renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedBackground")
                    renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledBackground")
                endif
>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
                if (my.isTristate)
>    property alias partiallyCheckedDefaultBackground: backgroundItem.partiallyCheckedDefaultBackground
>    property alias partiallyCheckedHoveredBackground: backgroundItem.partiallyCheckedHoveredBackground
>    property alias partiallyCheckedPressedBackground: backgroundItem.partiallyCheckedPressedBackground
>    property alias partiallyCheckedDisabledBackground: backgroundItem.partiallyCheckedDisabledBackground
                endif
>
>    background: SketchCheckBoxImageBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
                if (my.isTristate)
                    renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultBackground", 1, 1, 1)
                    renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredBackground", 1, 1, 1)
                    renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedBackground", 1, 1, 1)
                    renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledBackground", 1, 1, 1)
                endif
>    }
            else
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
                if (my.isTristate)
>    property alias partiallyCheckedDefaultBackground: backgroundItem.partiallyCheckedDefaultBackground
>    property alias partiallyCheckedHoveredBackground: backgroundItem.partiallyCheckedHoveredBackground
>    property alias partiallyCheckedPressedBackground: backgroundItem.partiallyCheckedPressedBackground
>    property alias partiallyCheckedDisabledBackground: backgroundItem.partiallyCheckedDisabledBackground
                endif
>
>    property real backgroundRadius: (backgroundItem.partData ? backgroundItem.partData.radius : 0)
>    property real backgroundTopLeftRadius: (backgroundItem.partData ? backgroundItem.partData.topLeftRadius : 0)
>    property real backgroundTopRightRadius: (backgroundItem.partData ? backgroundItem.partData.topRightRadius : 0)
>    property real backgroundBottomRightRadius: (backgroundItem.partData ? backgroundItem.partData.bottomRightRadius : 0)
>    property real backgroundBottomLeftRadius: (backgroundItem.partData ? backgroundItem.partData.bottomLeftRadius : 0)
>
>    background: SketchCheckBoxMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
                if (my.isTristate)
                    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultBackground", 1, 1, 1)
                    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredBackground", 1, 1, 1)
                    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedBackground", 1, 1, 1)
                    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledBackground", 1, 1, 1)
                endif
>    }
            endif
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif


    # Indicator
    my.indicator = checkbox_indicator(my.component)?
    if defined(my.indicator)
        my.indicatorType = bestIconType(my.indicator)

        if (my.indicatorType = "symbol")
>
>    property alias override_defaultIndicator: indicatorItem.override_defaultIndicator
>    property alias override_hoveredIndicator: indicatorItem.override_hoveredIndicator
>    property alias override_pressedIndicator: indicatorItem.override_pressedIndicator
>    property alias override_disabledIndicator: indicatorItem.override_disabledIndicator
>    property alias override_checkedDefaultIndicator: indicatorItem.override_checkedDefaultIndicator
>    property alias override_checkedHoveredIndicator: indicatorItem.override_checkedHoveredIndicator
>    property alias override_checkedPressedIndicator: indicatorItem.override_checkedPressedIndicator
>    property alias override_checkedDisabledIndicator: indicatorItem.override_checkedDisabledIndicator
            if (my.isTristate)
>    property alias override_partiallyCheckedDefaultIndicator: indicatorItem.override_partiallyCheckedDefaultIndicator
>    property alias override_partiallyCheckedHoveredIndicator: indicatorItem.override_partiallyCheckedHoveredIndicator
>    property alias override_partiallyCheckedPressedIndicator: indicatorItem.override_partiallyCheckedPressedIndicator
>    property alias override_partiallyCheckedDisabledIndicator: indicatorItem.override_partiallyCheckedDisabledIndicator
            endif
>
>    indicator: SketchCheckBoxVectorIndicator {
>    $(my.subIndent)id: indicatorItem
>    $(my.subIndent)control: root
            renderItemPositioning(my.indicator, 1, 1, 1)

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIndicator", 0)
            if (my.isTristate)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultIndicator", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredIndicator", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedIndicator", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledIndicator", 0)
            endif
>    }
        elsif (my.indicatorType = "text")
>
>    property alias indicatorItem: indicatorItem
>    property alias defaultIndicator: indicatorItem.defaultText
>    property alias hoveredIndicator: indicatorItem.hoveredText
>    property alias pressedIndicator: indicatorItem.pressedText
>    property alias disabledIndicator: indicatorItem.disabledText
>    property alias checkedDefaultIndicator: indicatorItem.checkedDefaultText
>    property alias checkedHoveredIndicator: indicatorItem.checkedHoveredText
>    property alias checkedPressedIndicator: indicatorItem.checkedPressedText
>    property alias checkedDisabledIndicator: indicatorItem.checkedDisabledText
            if (my.isTristate)
>    property alias partiallyCheckedDefaultIndicator: indicatorItem.partiallyCheckedDefaultText
>    property alias partiallyCheckedHoveredIndicator: indicatorItem.partiallyCheckedHoveredText
>    property alias partiallyCheckedPressedIndicator: indicatorItem.partiallyCheckedPressedText
>    property alias partiallyCheckedDisabledIndicator: indicatorItem.partiallyCheckedDisabledText
            endif
>
>    indicator: SketchCheckBoxText {
>    $(my.subIndent)id: indicatorItem
>    $(my.subIndent)control: root
            renderItemPositioning(my.indicator, 1, 1, 1)

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0, 0, 0, "defaultText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIndicator", 0, 0, 0, "hoveredText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIndicator", 0, 0, 0, "pressedText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0, 0, 0, "disabledText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIndicator", 0, 0, 0, "checkedDefaultText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIndicator", 0, 0, 0, "checkedHoveredText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIndicator", 0, 0, 0, "checkedPressedText")
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIndicator", 0, 0, 0, "checkedDisabledText")
            if (my.isTristate)
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultIndicator", 0, 0, 0, "partiallyCheckedDefaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredIndicator", 0, 0, 0, "partiallyCheckedHoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedIndicator", 0, 0, 0, "partiallyCheckedPressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledIndicator", 0, 0, 0, "partiallyCheckedDisabledText")
            endif
>    }
        else
>
>    property alias defaultIndicator: indicatorItem.defaultIndicator
>    property alias hoveredIndicator: indicatorItem.hoveredIndicator
>    property alias pressedIndicator: indicatorItem.pressedIndicator
>    property alias disabledIndicator: indicatorItem.disabledIndicator
>    property alias checkedDefaultIndicator: indicatorItem.checkedDefaultIndicator
>    property alias checkedHoveredIndicator: indicatorItem.checkedHoveredIndicator
>    property alias checkedPressedIndicator: indicatorItem.checkedPressedIndicator
>    property alias checkedDisabledIndicator: indicatorItem.checkedDisabledIndicator
            if (my.isTristate)
>    property alias partiallyCheckedDefaultIndicator: indicatorItem.partiallyCheckedDefaultIndicator
>    property alias partiallyCheckedHoveredIndicator: indicatorItem.partiallyCheckedHoveredIndicator
>    property alias partiallyCheckedPressedIndicator: indicatorItem.partiallyCheckedPressedIndicator
>    property alias partiallyCheckedDisabledIndicator: indicatorItem.partiallyCheckedDisabledIndicator
            endif
>
>    indicator: SketchCheckBoxImageIndicator {
>    $(my.subIndent)id: indicatorItem
>    $(my.subIndent)control: root
            renderItemPositioning(my.indicator, 1, 1, 1)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIndicator", 0, 0, 0)
            if (my.isTristate)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultIndicator", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredIndicator", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedIndicator", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledIndicator", 0, 0, 0)
            endif
>    }
        endif
    endif


    # Label
    my.hasLabel = checkbox_hasLabel(my.component)
    if (my.hasLabel)
>
>    property alias defaultText: textItem.defaultText
>    property alias hoveredText: textItem.hoveredText
>    property alias pressedText: textItem.pressedText
>    property alias disabledText: textItem.disabledText
>    property alias checkedDefaultText: textItem.checkedDefaultText
>    property alias checkedHoveredText: textItem.checkedHoveredText
>    property alias checkedPressedText: textItem.checkedPressedText
>    property alias checkedDisabledText: textItem.checkedDisabledText
        if (my.isTristate)
>    property alias partiallyCheckedDefaultText: textItem.partiallyCheckedDefaultText
>    property alias partiallyCheckedHoveredText: textItem.partiallyCheckedHoveredText
>    property alias partiallyCheckedPressedText: textItem.partiallyCheckedPressedText
>    property alias partiallyCheckedDisabledText: textItem.partiallyCheckedDisabledText
        endif
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
>
>    contentItem: SketchCheckBoxText {
>    $(my.subIndent)id: textItem
>    $(my.subIndent)control: root
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledText", 1, 1, 1)
        if (my.isTristate)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDefaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedHoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedPressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "partiallyCheckedDisabledText", 1, 1, 1)
        endif
>   }
    endif

    # Extra children
    for my.component.item where !checkbox_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_CheckBox


############### Special case: Combobox ###############


function combobox_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|opened)Background$", my.usedName)
endfunction combobox_isBackgroundLayer


function combobox_isPopupLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^popup(Background|Item|Scrollbar)$", my.usedName) 
endfunction combobox_isPopupLayer


function combobox_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(focus|hover|press)Feedback$", my.usedName)
endfunction combobox_isFeedbackLayer


function combobox_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press)Feedback$", my.usedName)
endfunction combobox_isSpecialFeedback


function combobox_isOtherLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(textfield|(default|disabled)Indicator)$", my.usedName) 
endfunction combobox_isOtherLayer


function combobox_isExpectedLayer(name)
    return (combobox_isBackgroundLayer(my.name) | combobox_isPopupLayer(my.name) | combobox_isOtherLayer(my.name) | combobox_isFeedbackLayer(my.name))
endfunction combobox_isExpectedLayer


function combobox_background(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressedBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hoveredBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "openedBackground")?
    endif

    return my.item
endfunction combobox_background


function combobox_determinePopupBackgroundType(component)
    my.item = getChildNamed(my.component, "popupBackground")?
    return bestType(my.item)
endfunction combobox_determinePopupBackgroundType


function combobox_indicator(component)
    my.item = getChildNamed(my.component, "defaultIndicator")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledIndicator")?
    endif
    return my.item
endfunction combobox_indicator


function combobox_bestIndicatorType(item)
    # image or symbol only
    return bestIconType_legacy(my.item) 
endfunction combobox_bestIndicatorType


function combobox_isBackgroundOrFeedbackLayer(name)
    return (combobox_isBackgroundLayer(my.name) | combobox_isFeedbackLayer(my.name))
endfunction combobox_isBackgroundOrFeedbackLayer


function combobox_itemIsAboveBackgroundLayers(component, targetName)
    my.targetItemIndex = -1
    my.lastBackgroundOrContentIndex = -1
    for my.component.item where combobox_isBackgroundOrFeedbackLayer(name)
        my.currentIndex = index()
        if (string.lexcmp("$(name:camel)", my.targetName) = 0)
            my.targetItemIndex = my.currentIndex 
        elsif (my.currentIndex > my.lastBackgroundOrContentIndex)
            my.lastBackgroundOrContentIndex = my.currentIndex
        endif
    endfor

    return (my.targetItemIndex > my.lastBackgroundOrContentIndex)
endfunction combobox_itemIsAboveBackgroundLayers


function combobox_renderIndicatorPositioning(component, indicator, level)
    my.indent = getIndent(my.level)
    my.subIndent = getIndent(1)

    # We assume that an indicator is always anchored on top-right corner
    my.deltaRight = my.component.width - my.indicator.width - my.indicator.x
    my.deltaTop = my.indicator.y
>
>    $(my.indent)anchors {
>    $(my.indent)$(my.subIndent)top: parent.top
>    $(my.indent)$(my.subIndent)topMargin: $(my.deltaTop)
>    $(my.indent)$(my.subIndent)right: parent.right
>    $(my.indent)$(my.subIndent)rightMargin: $(my.deltaRight)
>    $(my.indent)}
>
>    $(my.indent)width: $(my.indicator.width)
>    $(my.indent)height: $(my.indicator.height)
endfunction combobox_renderIndicatorPositioning


function renderComponent_Combobox(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchComboBox {
>    id: root
>
>    // To fill our combobox
>    model: ["Apple", "Banana", "Kiwi", "Lemon", "Orange", "Papaya", "Peach"]
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !combobox_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "focusFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Focus feedback
    my.focusFeedbackIsAbove = combobox_itemIsAboveBackgroundLayers(my.component, "focusFeedback")
    if !renderComponent_Feedback(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusFeedback", "root.visualFocus", focusFeedbackZ(my.focusFeedbackIsAbove))
>
>    activeFocusOnTab: false
>
    endif

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = combobox_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background 
    my.background = button_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>
>    background: SketchComboBoxSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "openedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            elsif (my.backgroundType = "image")
>
>    background: SketchComboBoxImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "openedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
            else
>
>    background: SketchComboBoxMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "openedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>
            endif

            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState")
>    }
        elsif (my.hasBackground)
            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_hoveredBackground: backgroundItem.override_hoveredBackground
>    property alias override_pressedBackground: backgroundItem.override_pressedBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground
>    property alias override_openedBackground: backgroundItem.override_openedBackground
>
>    background: SketchComboBoxSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "openedBackground")
>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias openedBackground: backgroundItem.openedBackground
>
>    background: SketchComboBoxMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "openedBackground", 0, 0, 0)
>    }
            else
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias openedBackground: backgroundItem.openedBackground
>
>    background: SketchComboBoxMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "openedBackground", 1, 1, 1)
>    }
            endif
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif


    # Indicator
    my.indicator = combobox_indicator(my.component)?
    if defined(my.indicator)
        my.indicatorType = combobox_bestIndicatorType(my.indicator)
>
        if (my.indicatorType = "symbol")
>    property alias override_defaultIndicator: comboboxIndicator.override_defaultIndicator
>    property alias override_disabledIndicator: comboboxIndicator.override_disabledIndicator
>
>    indicator: SketchComboBoxSymbolIndicator {
>    $(my.subIndent)id: comboboxIndicator
>    $(my.subIndent)control: root
            combobox_renderIndicatorPositioning(my.component, my.indicator, 1)

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0)
        else
>    property alias defaultIndicator: comboboxIndicator.defaultIndicator
>    property alias disabledIndicator: comboboxIndicator.disabledIndicator
>
>    indicator: SketchComboBoxImageIndicator {
>    $(my.subIndent)id: comboboxIndicator
>    $(my.subIndent)control: root
            combobox_renderIndicatorPositioning(my.component, my.indicator, 1)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0, 0, 0)
        endif
>
>    $(my.subIndent)rotation: root.openedState ? -180 : 0
>
>    $(my.subIndent)Behavior on rotation {
>    $(my.subIndent)$(my.subIndent)NumberAnimation {
>    $(my.subIndent)$(my.subIndent)$(my.subIndent)duration: root.indicatorAnimationDurationInMilliseconds
>    $(my.subIndent)$(my.subIndent)}
>    $(my.subIndent)}
>    }
    else
         echo "Sketch2Qml warning: Combobox $(my.component.name) does not have a child named 'defaultIndicator' or 'disabledIndicator'"
    endif


    # Textfield
    my.textfield = getChildNamed(my.component, "textfield")?
    if defined(my.textfield)
        if isSymbolInstance(my.textfield)
>
            my.leftPadding = my.textfield.x
            my.rightPadding = my.component.width - (my.textfield.x + my.textfield.width)
            my.topPadding = my.textfield.y
            my.bottomPadding = my.component.height - (my.textfield.y + my.textfield.height)
>    leftPadding: $(my.leftPadding)
>    rightPadding: $(my.rightPadding)
>    topPadding: $(my.topPadding)
>    bottomPadding: $(my.bottomPadding)
>    property alias textfield: textfield
>    placeholderText: textfield.placeholder ? textfield.placeholder.text : qsTr("Select")
            renderSymbolAsProperty(my.appOrLibrary, my.textfield, 0, my.isInLibrary, "contentItem", 1, 0, "textfield")
>
>    $(my.subIndent)enabled: root.editable
>    $(my.subIndent)canUseDisabledState: !root.enabled
>    $(my.subIndent)autoScroll: root.editable
>    $(my.subIndent)validator: root.validator
>    $(my.subIndent)selectByMouse: root.selectTextByMouse
>    $(my.subIndent)placeholderText: root.placeholderText
>    $(my.subIndent)text: root.editable ? root.editText : root.displayText
>    }
        else
            echo "Sketch2Qml warning: Combobox $(my.component.name) contains a child named 'textfield' that is not a symbol instance"
        endif
    else
        echo "Sketch2Qml warning: Combobox $(my.component.name) does not have a child named 'textfield'"
    endif


    # Popup background
    my.popupBackgroundType = combobox_determinePopupBackgroundType(my.component)
>
    if (my.popupBackgroundType = "symbol")
>    property alias override_popupBackground: comboboxPopupBackground.contentItem
>    comboboxPopup.background: SketchControlSymbolPart {
>    $(my.subIndent)id: comboboxPopupBackground
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "popupBackground", 1, "contentItem")
>    }
    elsif (my.popupBackgroundType = "image")
>    property alias popupBackground: comboboxPopupBackground.partData
>    comboboxPopup.background: SketchControlImagePart {
>    $(my.subIndent)id: comboboxPopupBackground
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "popupBackground", 0, 0, 0, "partData")
>    }
    else
>    property alias popupBackground: comboboxPopupBackground.partData
>    comboboxPopup.background: SketchControlMaterialPart {
>    $(my.subIndent)id: comboboxPopupBackground
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "popupBackground", 1, 1, 1, "partData")
>    }
    endif

    # Popup item
    my.popupItem = getChildNamed(my.component, "popupItem")?
    if defined(my.popupItem)
        if isSymbolInstance(my.popupItem)
>
>    itemHeight: $(my.popupItem.height)
            renderSymbolAsProperty(my.appOrLibrary, my.popupItem, 0, my.isInLibrary, "delegate", 1, 0)
>
>    $(my.subIndent)width: ListView.view.width
>    $(my.subIndent)isFirst: (index === 0)
>    $(my.subIndent)isLast: (index === (ListView.view.count - 1))
>    $(my.subIndent)highlighted: (root.highlightedIndex === index)
>    $(my.subIndent)//Qt 6.5.3 - QTBUG-112291: Array.isArray is unreliable
>    $(my.subIndent)//TODO: Qt 6.8 - update the definition of our delegate see quickcontrols/basic/ComboBox.qml
>    $(my.subIndent)selected: root.isCurrentIndex(index, root.valueRole ? ((root.model instanceof Array) ? modelData[root.valueRole] : model[root.valueRole]) : modelData)
>    $(my.subIndent)text: root.prettyPrint(root.textRole ? ((root.model instanceof Array) ? modelData[root.textRole] : model[root.textRole]) : modelData)
>    }
        else
            echo "Sketch2Qml warning: Combobox $(my.component.name) contains a child named 'popupItem' that is not a symbol instance"
        endif
    else
        echo "Sketch2Qml warning: Combobox $(my.component.name) does not have a child named 'popupItem'"
    endif


    # Popup scrollbar
    my.popupScrollbar = getChildNamed(my.component, "popupScrollbar")?
    if defined(my.popupScrollbar)
        if isSymbolInstance(my.popupScrollbar)
>
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.popupScrollbar, 1, my.isInLibrary, "override_popupScrollbar: ", 1, 1, 0)
>
>    $(my.subIndent)policy: (comboboxPopup.contentItem && (comboboxPopup.contentItem.contentHeight > comboboxPopup.contentItem.height)) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff
>    }
        else
            echo "Sketch2Qml warning: Combobox $(my.component.name) contains a child named 'popupScrollbar' that is not a symbol instance"
        endif
    endif


    # Extra children
    for my.component.item where !combobox_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_Combobox


############### Special case: ComboboxItem ###############


function comboboxitem_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|active|pressed|selected(Default|Active|Pressed))Background$", my.usedName)
endfunction comboboxitem_isBackgroundLayer


function comboboxitem_background(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "selectedBackground")?
    endif
    return my.item
endfunction comboboxitem_background


function comboboxitem_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|active|pressed|selected(Default|Active|Pressed))Text$", my.usedName) 
endfunction comboboxitem_isTextLayer


function comboboxitem_isExpectedLayer(name)
    return (comboboxitem_isBackgroundLayer(my.name) | comboboxitem_isTextLayer(my.name) | comboboxitem_isFeedbackLayer(my.name))
endfunction comboboxitem_isExpectedLayer


function comboboxitem_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(active|press)Feedback$", my.usedName)
endfunction comboboxitem_isFeedbackLayer


function comboboxitem_determineBackgroundType(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressedBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "activeBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "selectedDefaultBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "selectedPressedBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "selectedActiveBackground")?
    endif

    return bestType(my.item)
endfunction comboboxitem_determineBackgroundType


function renderComponent_ComboboxItem(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>    
    my.background = comboboxitem_background(my.component)?
    my.hasBackground = defined(my.background)
    #NB: we dont' use bestType because background may be undefined
    my.backgroundType = comboboxitem_determineBackgroundType(my.component)

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = comboboxitem_isFeedbackLayer(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    if (my.containsHoverOrPressFeedback)
        # State layers and feedback layers
>BaseSketchComboBoxItem {
    else
        # State layers only
        if (my.backgroundType = "symbol")
>SketchSymbolComboBoxItem {
        elsif (my.backgroundType = "image")
>SketchImageComboBoxItem {
        else
>SketchMaterialComboBoxItem {
        endif
    endif

>    id: root

    # Implicit size
    if (!my.containsHoverOrPressFeedback & (my.backgroundType = "material"))
        #NB: rectangles don't have an implicit size, we need to define it
        renderItemImplicitSize(my.component, 0)
    endif

>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !comboboxitem_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "activeFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Background
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (!my.hasBackground)
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>
>    background: SketchComboBoxItemSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "selectedBackground")
            elsif (my.backgroundType = "image")
>
>    background: SketchComboBoxItemImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "selectedBackground", 1, 1, 1)
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
            else
>
>    background: SketchComboBoxItemMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "selectedBackground", 1, 1, 1)
>
            endif

            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "activeFeedback", "root.activeState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState")
>    }
        elsif (my.hasBackground)
            # No feedbacks

            if (my.backgroundType = "symbol")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedActiveBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedPressedBackground")
            elsif (my.backgroundType = "image")
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedDefaultBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedActiveBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedPressedBackground", 0, 0, 0)
            else
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedActiveBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedPressedBackground", 1, 1, 1)
            endif
        endif
    endif


    # Text
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedDefaultText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedActiveText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectedPressedText", 1, 1, 1)

    # Extra children
    for my.component.item where !comboboxitem_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_ComboboxItem



############### Special case: List ###############


function list_isExpectedLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(item|scrollbar)$", my.usedName)
endfunction list_isExpectedLayer


function renderComponent_List(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importQtQuickTemplates()
>
>  
>ListView {
>    id: root

    #NB: custom item - we need an implicit size
    renderItemImplicitSize(my.component, 0)

>
>    // To allow symbol override
>    property alias override_item: root.delegate
>
>    // To fill our list
>    model: 30
>
>    clip: (height < contentHeight)
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !list_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    my.scrollbar = getChildNamed(my.component, "scrollbar")?
    if defined(my.scrollbar)
        if isSymbolInstance(my.scrollbar)
>
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.scrollbar, 1, my.isInLibrary, "property T.ScrollBar override_scrollbar: ", 1, 1, 0)
>
>    $(my.subIndent)policy: (root.contentHeight > root.height) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff 
>    }
>
>    T.ScrollBar.vertical: root.override_scrollbar
        else
            echo "Sketch2Qml warning: List $(my.component.name) contains a child named 'scrollbar' that is not a symbol instance"
        endif
    endif

    my.item = getChildNamed(my.component, "item")?
    if defined(my.item)
        # Reset forbidden properties
        my.item.y = 0
        my.item.hasFixedTop = 0
        my.item.hasFixedBottom = 0
>    
        if isSymbolInstance(my.item)
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.item, 1, my.isInLibrary, "delegate: ", 1, 1, 1)
        else
            iterateOnItem(my.appOrLibrary, my.item, 1, my.isInLibrary, "delegate: ")
        endif
    else
        echo "Sketch2Qml warning: List $(my.component.name) does not have a child named 'item'"
    endif

    # Extra children
    for my.component.item where !list_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_List



############### Special case: Menu ###############


function menu_isExpectedLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(defaultBackground|item|scrollbar)$", my.usedName) 
endfunction menu_isExpectedLayer


function renderComponent_Menu(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchMenu {
>    id: root

    renderItemUserSetProperties(my.component, 0)

    # Aliases of extra children
    for my.component.item where !menu_isExpectedLayer(name)
        if first()
>
        endif

        #NB: we assume that instances defined inside a menu are menu items
        # Since a QML Menu can only accept MenuItem or Action as children, we render non overridable symbols
        if isSymbolInstance(item)
            generatePropertyAliasesForNonOverridableSymbolInstance(item, "", "")
        else
            generatePropertyAliases(item, "", "")
        endif
    endfor

    # Background 
    my.background = getChildNamed(my.component, "defaultBackground")?
    if defined(my.background)
        my.backgroundType = bestType(my.background)
>
        if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: menuBackground.contentItem
>    background: SketchControlSymbolPart {
>    $(my.subIndent)id: menuBackground
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, "contentItem")
>    }
        elsif (my.backgroundType = "image")
>    property alias defaultBackground: menuBackground.partData
>    background: SketchControlImagePart {
>    $(my.subIndent)id: menuBackground
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        else
>    property alias defaultBackground: menuBackground.partData
>    background: SketchControlMaterialPart {
>    $(my.subIndent)id: menuBackground
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        endif
    endif


    # Scrollbar
    my.scrollbar = getChildNamed(my.component, "scrollbar")?
    if defined(my.scrollbar)
        if isSymbolInstance(my.scrollbar)
>
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.scrollbar, 1, my.isInLibrary, "override_scrollbar: ", 1, 1, 0)
>    $(my.subIndent)policy: (root.contentItem && (root.contentItem.contentHeight > root.contentItem.height)) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff
>    }
        else
            echo "Sketch2Qml warning: Menu $(my.component.name) contains a child named 'scrollbar' that is not a symbol instance"
        endif
    endif


    # Item
    my.menuItem = getChildNamed(my.component, "item")?
    if defined (my.menuItem)
        if isSymbolInstance(my.menuItem)
>
            renderSymbolAsProperty(my.appOrLibrary, my.menuItem, 0, my.isInLibrary, "delegate", 0, 0)
>
>    $(my.subIndent)text: undefined
>
>    $(my.subIndent)onImplicitWidthChanged: {
>    $(my.subIndent)$(my.subIndent)root.adjustWidth();
>    $(my.subIndent)}
>    }
>
>    // To fill our menu (test pourpose only)
>    // YOU SHOULD COMMENT THESE TWO LINES TO OPTIMIZE THIS MENU
>    property list<QtObject> testActions: [Action {text: qsTr("Action 1")}, Action {text: qsTr("Action 2")}]
>    contentData: testActions
        else
            echo "Sketch2Qml warning: MenuItem $(my.component.name) contains a child named 'item' that is not a symbol instance"
        endif
    endif

    # Extra children
    for my.component.item where !menu_isExpectedLayer(name)
>    
        #NB: we assume that instances defined inside a menu are menu items
        # Since a QML Menu can only accept MenuItem or Action as children, we render non overridable symbols
        if isSymbolInstance(item)
            renderNonOverridableSymbolInstance(my.appOrLibrary, item, 1, my.isInLibrary, "", 1, 1, 1)
        else
            iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
        endif
    endfor
>}
endfunction renderComponent_Menu


############### Special case: MenuItem ###############


function menuitem_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|active|pressed|disabled)Background$", my.usedName)
endfunction menuitem_isBackgroundLayer


function menuitem_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|active|pressed|disabled)Text$", my.usedName) 
endfunction menuitem_isTextLayer


function menuitem_isExpectedLayer(name)
    return (menuitem_isBackgroundLayer(my.name) | menuitem_isTextLayer(my.name) | menuitem_isFeedbackLayer(my.name))
endfunction menuitem_isExpectedLayer


function menuitem_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(active|press)Feedback$", my.usedName)
endfunction menuitem_isFeedbackLayer


function menuitem_background(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressedBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "activeBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledBackground")?
    endif

    return my.item
endfunction menuitem_background


function renderComponent_MenuItem(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>    
>SketchMenuItem {
>    id: root

    renderItemUserSetProperties(my.component, 0)

    # Aliases of extra children
    for my.component.item where !menuitem_isExpectedLayer(name)
        if first()
>
        endif
        generatePropertyAliases(item, "", "")
    endfor

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = menuitem_isFeedbackLayer(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background
    my.background = menuitem_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            #
            # UI based on feedback layers
            #
            if (my.backgroundType = "symbol")
>
>    background: SketchMenuItemSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            elsif (my.backgroundType = "image")
>
>    background: SketchMenuItemImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
>
            else
>
>    background: SketchMenuItemMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 0)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>
            endif

            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "activeFeedback", "root.activeState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState")
>    }
        elsif (my.hasBackground)
            #
            # UI based on state layers (one layer per state)
            #
            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: menuItemBackground.override_defaultBackground
>    property alias override_activeBackground: menuItemBackground.override_activeBackground
>    property alias override_pressedBackground: menuItemBackground.override_pressedBackground
>    property alias override_disabledBackground: menuItemBackground.override_disabledBackground
>    background: SketchMenuItemSymbolBackground {
>    $(my.subIndent)id: menuItemBackground
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "activeBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: menuItemBackground.defaultBackground
>    property alias activeBackground: menuItemBackground.activeBackground
>    property alias pressedBackground: menuItemBackground.pressedBackground
>    property alias disabledBackground: menuItemBackground.disabledBackground
>    background: SketchMenuItemImageBackground {
>    $(my.subIndent)id: menuItemBackground
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "activeBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>    }
            else
>    property alias defaultBackground: menuItemBackground.defaultBackground
>    property alias activeBackground: menuItemBackground.activeBackground
>    property alias pressedBackground: menuItemBackground.pressedBackground
>    property alias disabledBackground: menuItemBackground.disabledBackground
>    background: SketchMenuItemMaterialBackground {
>    $(my.subIndent)id: menuItemBackground
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 0)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "activeBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>    }
            endif 
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif

    # Text
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledText", 1, 1, 1)


    # Extra children
    for my.component.item where !menuitem_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_MenuItem


############### Special case: Popup ###############

function popup_isExpectedLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(defaultBackground|modalOverlay|modelessOverlay)$", my.usedName)
endfunction popup_isExpectedLayer


function renderComponent_Popup(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importQtQuickTemplates()
    importExtraQmlModules()
>
>
>SketchPopup {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>

    my.modalOverlay = getChildNamed(my.component, "modalOverlay")?
    my.modelessOverlay = getChildNamed(my.component, "modelessOverlay")?
>
    if (defined(my.modalOverlay) & !defined(my.modelessOverlay))
>    modal: true
>
    endif

    # Aliases of extra children
    my.hasExtraChildren = 0
    for my.component.item where !popup_isExpectedLayer(name)
        my.hasExtraChildren = 1
        generatePropertyAliases(item, "", "")
    endfor


    # Background
    my.background = getChildNamed(my.component, "defaultBackground")?
    if defined(my.background)
        my.backgroundType = bestType(my.background)
>
        if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: popupBackground.contentItem
>    background: SketchControlSymbolPart {
>    $(my.subIndent)id: popupBackground
            #NB: symbols have an implicit size, we don't need to define it
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, "contentItem")
>    }
        elsif (my.backgroundType = "image")
>    property alias defaultBackground: popupBackground.partData
>    background: SketchControlImagePart {
>    $(my.subIndent)id: popupBackground
            #NB: images have an implicit size, we don't need to define it
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        else
>    property alias defaultBackground: popupBackground.partData
>    background: SketchControlMaterialPart {
>    $(my.subIndent)id: popupBackground
            #NB: rectangles don't have an implicit size, we need to define it
            renderItemImplicitSize(my.component, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        endif
    endif


    #
    # Overlays
    #
    if defined(my.modalOverlay)
>
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "modalOverlay", 0, 0, 0, "property RectangleData modalOverlay")
>
>    T.Overlay.modal: Rectangle {
>        //NB: opacity is not taken into account by Overlay that's why we provide an ARGB color
>        color: SketchUtils.multiplyAlpha(modalOverlay.fillColor, modalOverlay.opacity)
>    }
    endif

    if defined(my.modelessOverlay)
>
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "modelessOverlay", 0, 0, 0, "property RectangleData modelessOverlay")
>
>    T.Overlay.modeless: Rectangle {
>        //NB: opacity is not taken into account by Overlay that's why we provide an ARGB color
>        color: SketchUtils.multiplyAlpha(modelessOverlay.fillColor, modelessOverlay.opacity)
>    }
    endif

    #
    # Extra children i.e. content of our popup
    #
    if (my.hasExtraChildren)
>
>    contentItem: Item {
        renderItemImplicitSize(my.component, 1)
        for my.component.item where !popup_isExpectedLayer(name)
>
            iterateOnItem(my.appOrLibrary, item, 2, my.isInLibrary, "")
        endfor
>    }
    endif
>}
endfunction renderComponent_Popup


############### Special case: RadioButton ###############


function radiobutton_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|checked(Default|Hovered|Pressed|Disabled))Background$", my.usedName) 
endfunction radiobutton_isBackgroundLayer


function radiobutton_isIndicatorLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|checked(Default|Hovered|Pressed|Disabled))Indicator$", my.usedName) 
endfunction radiobutton_isIndicatorLayer


function radiobutton_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|checked(Default|Hovered|Pressed|Disabled))Text$", my.usedName) 
endfunction radiobutton_isTextLayer


function radiobutton_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(focus|hover|press)Feedback$", my.usedName)
endfunction radiobutton_isFeedbackLayer


function radiobutton_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press)Feedback$", my.usedName)
endfunction radiobutton_isSpecialFeedback


function radiobutton_isExpectedLayer(name)
    return (radiobutton_isBackgroundLayer(my.name) | radiobutton_isIndicatorLayer(my.name) | radiobutton_isTextLayer(my.name) | radiobutton_isFeedbackLayer(my.name))
endfunction radiobutton_isExpectedLayer


function radiobutton_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif

    if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedDefault$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedHovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedPressed$(my.suffix)")?
    endif
    if !defined(my.item)
       my.item = getChildNamed(my.component, "checkedDisabled$(my.suffix)")?
    endif

    return my.item
endfunction radiobutton_itemWithStates


function radiobutton_background(component)
    return radiobutton_itemWithStates(my.component, "Background")
endfunction radiobutton_background


function radiobutton_indicator(component)
    return radiobutton_itemWithStates(my.component, "Indicator")
endfunction radiobutton_indicator


function radiobutton_hasLabel(component)
    my.item = radiobutton_itemWithStates(my.component, "Text")?
    return defined(my.item)
endfunction radiobutton_hasLabel


function radiobutton_isBackgroundOrFeedbackLayer(name)
    return (radiobutton_isBackgroundLayer(my.name) | radiobutton_isFeedbackLayer(my.name))
endfunction radiobutton_isBackgroundOrFeedbackLayer


function radiobutton_itemIsAboveBackgroundLayers(component, targetName)
    my.targetItemIndex = -1
    my.lastBackgroundOrContentIndex = -1
    for my.component.item where radiobutton_isBackgroundOrFeedbackLayer(name)
        my.currentIndex = index()
        if (string.lexcmp("$(name:camel)", my.targetName) = 0)
            my.targetItemIndex = my.currentIndex 
        elsif (my.currentIndex > my.lastBackgroundOrContentIndex)
            my.lastBackgroundOrContentIndex = my.currentIndex
        endif
    endfor

    return (my.targetItemIndex > my.lastBackgroundOrContentIndex)
endfunction radiobutton_itemIsAboveBackgroundLayers


function renderComponent_RadioButton(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchRadioButton {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !radiobutton_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor


    # Focus feedback
    my.focusFeedbackIsAbove = radiobutton_itemIsAboveBackgroundLayers(my.component, "focusFeedback")
    if !renderComponent_Feedback(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusFeedback", "root.visualFocus", focusFeedbackZ(my.focusFeedbackIsAbove))
>
>    activeFocusOnTab: false
>
    endif

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = radiobutton_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background
    my.background = radiobutton_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif
>
>    property alias backgroundItem: backgroundItem

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>    background: SketchRadioButtonSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to use it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
            
            elsif (my.backgroundType = "image")
>    background: SketchRadioButtonImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
            
            elsif (my.backgroundType = "none")
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
>
            else
>    background: SketchRadioButtonMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
            endif
>
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState || root.checkedHoveredState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState || root.checkedPressedState")
>    }
        elsif (my.hasBackground)
>
            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_hoveredBackground: backgroundItem.override_hoveredBackground
>    property alias override_pressedBackground: backgroundItem.override_pressedBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground
>    property alias override_checkedDefaultBackground: backgroundItem.override_checkedDefaultBackground
>    property alias override_checkedHoveredBackground: backgroundItem.override_checkedHoveredBackground
>    property alias override_checkedPressedBackground: backgroundItem.override_checkedPressedBackground
>    property alias override_checkedDisabledBackground: backgroundItem.override_checkedDisabledBackground
>
> 
>    background: SketchRadioButtonSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: symbols have an implicit size, we don't need to define it

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>
>    background: SketchRadioButtonImageBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: images have an implicit size, we don't need to define it

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
>    }
            else
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>    property real backgroundRadius: (backgroundItem.partData ? backgroundItem.partData.radius : 0)
>    property real backgroundTopLeftRadius: (backgroundItem.partData ? backgroundItem.partData.topLeftRadius : 0)
>    property real backgroundTopRightRadius: (backgroundItem.partData ? backgroundItem.partData.topRightRadius : 0)
>    property real backgroundBottomRightRadius: (backgroundItem.partData ? backgroundItem.partData.bottomRightRadius : 0)
>    property real backgroundBottomLeftRadius: (backgroundItem.partData ? backgroundItem.partData.bottomLeftRadius : 0)
>
>
>    background: SketchRadioButtonMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: rectangles don't have an implicit size, we need to define it
            renderItemImplicitSize(my.component, 1)

            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
>    }
            endif
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif 


    # Indicator
    my.indicator = radiobutton_indicator(my.component)?
    if defined(my.indicator)
        my.indicatorType = bestIconType(my.indicator)

        if (my.indicatorType = "symbol")
>
>    property alias override_defaultIndicator: indicatorItem.override_defaultIndicator
>    property alias override_hoveredIndicator: indicatorItem.override_hoveredIndicator
>    property alias override_pressedIndicator: indicatorItem.override_pressedIndicator
>    property alias override_disabledIndicator: indicatorItem.override_disabledIndicator
>    property alias override_checkedDefaultIndicator: indicatorItem.override_checkedDefaultIndicator
>    property alias override_checkedHoveredIndicator: indicatorItem.override_checkedHoveredIndicator
>    property alias override_checkedPressedIndicator: indicatorItem.override_checkedPressedIndicator
>    property alias override_checkedDisabledIndicator: indicatorItem.override_checkedDisabledIndicator
>
>    indicator: SketchRadioButtonVectorIndicator {
>    $(my.subIndent)id: indicatorItem
>    $(my.subIndent)control: root
            renderItemPositioning(my.indicator, 1, 1, 1)

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0)

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIndicator", 0)
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIndicator", 0)
>    }
        elsif (my.indicatorType = "text")
>
>    property alias indicatorItem: indicatorItem
>    property alias defaultIndicator: indicatorItem.defaultText
>    property alias hoveredIndicator: indicatorItem.hoveredText
>    property alias pressedIndicator: indicatorItem.pressedText
>    property alias disabledIndicator: indicatorItem.disabledText
>    property alias checkedDefaultIndicator: indicatorItem.checkedDefaultText
>    property alias checkedHoveredIndicator: indicatorItem.checkedHoveredText
>    property alias checkedPressedIndicator: indicatorItem.checkedPressedText
>    property alias checkedDisabledIndicator: indicatorItem.checkedDisabledText
>
>    indicator: SketchRadioButtonText {
>    $(my.subIndent)id: indicatorItem
>    $(my.subIndent)control: root
            renderItemPositioning(my.indicator, 1, 1, 1)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0, 0, 0, "defaultText")
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIndicator", 0, 0, 0, "hoveredText")
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIndicator", 0, 0, 0, "pressedText")
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0, 0, 0, "disabledText")

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIndicator", 0, 0, 0, "checkedDefaultText")
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIndicator", 0, 0, 0, "checkedHoveredText")
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIndicator", 0, 0, 0, "checkedPressedText")
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIndicator", 0, 0, 0, "checkedDisabledText")
>    }
        else
>
>    property alias defaultIndicator: indicatorItem.defaultIndicator
>    property alias hoveredIndicator: indicatorItem.hoveredIndicator
>    property alias pressedIndicator: indicatorItem.pressedIndicator
>    property alias disabledIndicator: indicatorItem.disabledIndicator
>    property alias checkedDefaultIndicator: indicatorItem.checkedDefaultIndicator
>    property alias checkedHoveredIndicator: indicatorItem.checkedHoveredIndicator
>    property alias checkedPressedIndicator: indicatorItem.checkedPressedIndicator
>    property alias checkedDisabledIndicator: indicatorItem.checkedDisabledIndicator
>
>    indicator: SketchRadioButtonImageIndicator {
>    $(my.subIndent)id: indicatorItem
>    $(my.subIndent)control: root
            renderItemPositioning(my.indicator, 1, 1, 1)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIndicator", 0, 0, 0)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIndicator", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIndicator", 0, 0, 0)
>    }
        endif
    endif


    # Label
    my.hasLabel = radiobutton_hasLabel(my.component)
    if (my.hasLabel)
>
>    property alias defaultText: textItem.defaultText
>    property alias hoveredText: textItem.hoveredText
>    property alias pressedText: textItem.pressedText
>    property alias disabledText: textItem.disabledText
>    property alias checkedDefaultText: textItem.checkedDefaultText
>    property alias checkedHoveredText: textItem.checkedHoveredText
>    property alias checkedPressedText: textItem.checkedPressedText
>    property alias checkedDisabledText: textItem.checkedDisabledText
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
>
>    contentItem: SketchRadioButtonText {
>    $(my.subIndent)id: textItem
>    $(my.subIndent)control: root
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedText", 1, 1, 1)
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledText", 1, 1, 1)
>   }
    endif


    # Extra children
    for my.component.item where !radiobutton_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor

>}
endfunction renderComponent_RadioButton


############### Special case: Scrollbar ###############


function scrollbar_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "active$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif

    return my.item
endfunction scrollbar_itemWithStates


function scrollbar_handle(component)
    return scrollbar_itemWithStates(my.component, "Handle")
endfunction scrollbar_handle


function scrollbar_determineType(component)
    my.item = scrollbar_handle(my.component)?

    if !defined(my.item)
        my.item = scrollbar_itemWithStates(my.component, "Background")?
    endif

    return bestType(my.item)
endfunction scrollbar_determineType


function scrollbar_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|active|pressed|disabled)Background$", my.usedName) 
endfunction scrollbar_isBackgroundLayer


function scrollbar_isHandleLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|active|pressed|disabled)Handle$", my.usedName) 
endfunction scrollbar_isHandleLayer


function scrollbar_isExpectedLayer(name)
    return (scrollbar_isHandleLayer(my.name) | scrollbar_isBackgroundLayer(my.name))
endfunction scrollbar_isExpectedLayer


function renderComponent_Scrollbar(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
>
>    
    my.controlsType = scrollbar_determineType(my.component)
    if (my.controlsType = "symbol")
>SketchSymbolScrollBar {
    elsif (my.controlsType = "image")
>SketchImageScrollBar {
    else
>SketchMaterialScrollBar {
    endif
>    id: root    
    renderItemImplicitSize(my.component, 0)
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !scrollbar_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    my.isVertical = (my.component.width <= my.component.height)

    # Background & handle
    if (my.controlsType = "symbol")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeBackground")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedBackground")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground")

        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultHandle")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeHandle")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedHandle")
        renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledHandle")
    elsif (my.controlsType = "image")
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 0, 0, 0)
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeBackground", 0, 0, 0)
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedBackground", 0, 0, 0)
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground", 0, 0, 0)

        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultHandle", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeHandle", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedHandle", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledHandle", 1, my.isVertical, !my.isVertical)
    else
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeBackground", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedBackground", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground", 1, my.isVertical, !my.isVertical)

        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultHandle", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "activeHandle", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "pressedHandle", 1, my.isVertical, !my.isVertical)
        renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledHandle", 1, my.isVertical, !my.isVertical)
    endif

    # Extra children
    for my.component.item where !scrollbar_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_Scrollbar


############### Special case: Scrollview ###############


function scrollview_isExpectedLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(vertical|horizontal)Scrollbar$", my.usedName) 
endfunction scrollview_isExpectedLayer


function renderComponent_Scrollview(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importQtQuickTemplates()
>
>  
>SketchScrollView {
>    id: root

    #NB: custom item - we need an implicit size
    renderItemImplicitSize(my.component, 0)
>
>
>    default property alias defaultProperty: rootContent.data
>    contentWidth: rootContent.width
>    contentHeight: rootContent.height
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !scrollview_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    my.horizontalScrollbar = getChildNamed(my.component, "horizontalScrollbar")?
    if defined(my.horizontalScrollbar)
        if isSymbolInstance(my.horizontalScrollbar)
>
>    property alias horizontalScrollbar: horizontalScrollbar
>    ScrollBar.horizontal: root.override_horizontalScrollbar
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.horizontalScrollbar, 1, my.isInLibrary, "property T.ScrollBar override_horizontalScrollbar: ", 1, 1, 0)
>    $(my.subIndent)policy: (root.contentWidth > root.width) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff 
>    }
        else
            echo "Sketch2Qml warning: Scrollview $(my.component.name) contains a child named 'horizontalScrollbar' that is not a symbol instance"
        endif
    endif

    my.verticalScrollbar = getChildNamed(my.component, "verticalScrollbar")?
    if defined(my.verticalScrollbar)
        if isSymbolInstance(my.verticalScrollbar)
>
>    property alias verticalScrollbar: verticalScrollbar
>    ScrollBar.vertical: root.override_verticalScrollbar
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.verticalScrollbar, 1, my.isInLibrary, "property T.ScrollBar override_verticalScrollbar: ", 1, 1, 0)
>    $(my.subIndent)policy: (root.contentHeight > root.height) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff 
>    }
        else
            echo "Sketch2Qml warning: Scrollview $(my.component.name) contains a child named 'verticalScrollbar' that is not a symbol instance"
        endif
    endif

    # Extra children i.e. content
> 
>
>    Item {
>        id: rootContent

    if defined(my.horizontalScrollbar)
>        implicitWidth: childrenRect.x + childrenRect.width
    else
>        implicitWidth: root.width
    endif

    if defined(my.verticalScrollbar)
>        implicitHeight: childrenRect.y + childrenRect.height
    else
>        implicitHeight: root.height
    endif

    for my.component.item where !scrollview_isExpectedLayer(name)
>    
        iterateOnItem(my.appOrLibrary, item, 2, my.isInLibrary, "")
    endfor
>    }
>}
endfunction renderComponent_Scrollview



############### Special case: Slider ###############


function slider_renderHandleOffsetX(component, indent)
    my.subIndent = getIndent(my.indent)

    my.defaultHandleWidth = 0
    my.defaultHandle = getChildNamed(my.component, "defaultHandle")?
    for my.defaultHandle.border
        my.defaultHandleWidth = my.defaultHandle.width
    endfor

    my.pressedHandleWidth = 0
    my.pressedHandle = getChildNamed(my.component, "pressedHandle")?
    for my.pressedHandle.border
        my.pressedHandleWidth = my.pressedHandle.width
    endfor

    my.hoveredHandleWidth = 0
    my.hoveredHandle = getChildNamed(my.component, "hoveredHandle")?
    for my.hoveredHandle.border
        my.hoveredHandleWidth = my.hoveredHandle.width
    endfor

    my.disabledHandleWidth = 0
    my.disabledHandle = getChildNamed(my.component, "disabledHandle")?
    for my.disabledHandle.border
        my.disabledHandleWidth = my.disabledHandle.width
    endfor

>    $(my.subIndent)readonly property real handleWidth: root.pressedState ? $(my.pressedHandleWidth) : (root.hoveredState ? $(my.hoveredHandleWidth) : (root.disabledState ? $(my.disabledHandleWidth) : $(my.defaultHandleWidth)))
>    $(my.subIndent)x: -handleWidth / 2
endfunction


function slider_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|disabled)Background$", my.usedName)
endfunction slider_isBackgroundLayer

function slider_isHandleLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|focused|hovered|pressed|disabled)Handle$", my.usedName)
endfunction slider_isHandleLayer

function slider_isProgressLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|disabled)Progress$", my.usedName)
endfunction slider_isProgressLayer


function slider_isExpectedLayer(name)
    return (slider_isBackgroundLayer(my.name) | slider_isHandleLayer(my.name) | slider_isProgressLayer(my.name))
endfunction slider_isExpectedLayer


function slider_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif

    return my.item
endfunction slider_itemWithStates


function slider_background(component)
    return slider_itemWithStates(my.component, "Background")
endfunction slider_background


function slider_progress(component)
    return slider_itemWithStates(my.component, "Progress")
endfunction slider_progress


function slider_handle(component)
    return slider_itemWithStates(my.component, "Handle")
endfunction slider_handle


function slider_renderSymbolAsProperty(appOrLibrary, item, level, isInLibrary, propertyName, defineImplicitSize, closeBlock, itemName)
    if isSymbolInstance(my.item)
        my.indent = getIndent(my.level)
        my.subIndent = getIndent(1)

        if !defined(my.itemName)
            my.itemName = "$(my.item.name:camel)"
        endif

>    $(my.indent)$(my.propertyName): $(my.item.type: Pascal) {
>    $(my.indent)$(my.subIndent)id: $(my.itemName)
>    $(my.indent)$(my.subIndent)objectName: "$(my.itemName)"
>
>    $(my.indent)$(my.subIndent)$(my.itemName).width: parent.width

        if (my.defineImplicitSize)
            renderItemImplicitSize(my.item, my.level + 1)
        endif

        renderOpacity("", my.item, my.level + 1)
        renderItemTransformations(my.item, my.level + 1)
        renderItemUserSetProperties(my.item, my.level + 1)
        renderSymbolInstanceOverrides(my.appOrLibrary, my.item, my.level + 1, my.isInLibrary)
        if my.closeBlock
>    $(my.indent)}
        endif
    endif
endfunction slider_renderSymbolAsProperty


function slider_renderComponentProperty_SymbolHandle(appOrLibrary, component, level, isInLibrary, itemName, addPadding, propertyName)
    my.indent = getIndent(my.level)

    if !defined(my.addPadding)
        # be default, we add padding data
        my.addPadding = 1
    endif

    if !defined(my.propertyName)
        my.renderAlias = 1
        my.propertyName = "$(my.itemName)"
    else
        # We use an existing property, we MUST not create an alias with the same name
        my.renderAlias = 0
    endif

    my.item = getChildNamed(my.component, my.itemName)?
    if (defined(my.item) & isSymbolInstance(my.item))
>
        if my.addPadding
            if my.renderAlias
                renderPadding("$(my.propertyName)_", my.item, my.level, my.component)
            else
                if (string.lexcmp(my.propertyName, "contentItem") = 0)
                    renderPadding("", my.item, my.level, my.component)
                else
                    echo "WARNING slider_renderComponentProperty_SymbolHandle: padding not yet implemented for $(my.propertyName)"
                endif
            endif
        endif

        if my.renderAlias
>    $(my.indent)property alias $(my.propertyName): $(my.itemName)
            slider_renderSymbolAsProperty(my.appOrLibrary, my.item, my.level, my.isInLibrary, "override_$(my.propertyName)", 1, 1, my.itemName)
        else
            slider_renderSymbolAsProperty(my.appOrLibrary, my.item, my.level, my.isInLibrary, "$(my.propertyName)", 1, 1, my.itemName)
        endif
    else
>
        if (defined(my.item) & !isSymbolInstance(my.item))
>    $(my.indent)// Sketch warning: layer $(my.itemName) is not a symbol instance, property $(my.propertyName) can not be rendered
            echo "Sketch2QML warning: layer $(my.itemName) is not a symbol instance, property $(my.propertyName) can not be rendered"
        endif

        if my.renderAlias
>    $(my.indent)property Item $(my.propertyName): null
        else
>    $(my.indent)$(my.propertyName): null
        endif
    endif
endfunction slider_renderComponentProperty_SymbolHandle


function slider_renderComponentProperty_RectangleDataHandle(appOrLibrary, component, level, isInLibrary, itemName, exportTopLeftPadding, exportRightPadding, exportBottomPadding, propertyName)

    if !defined(my.propertyName)
        my.propertyName = "$(my.itemName)"
    endif
    
    my.item = getChildNamed(my.component, my.itemName)?
    if defined(my.item)
        my.indent = getIndent(my.level)
        my.subIndent = getIndent(1)

        my.isRectangle = isRectangle(my.item)
        my.isOval = isOval(my.item)

        if (my.isRectangle | my.isOval)
>
>    $(my.indent)$(my.propertyName): RectangleData {
>    $(my.indent)$(my.subIndent)width: root.visualPosition * root.availableWidth
            renderOpacity("", my.item, my.level + 1)

            if (my.isRectangle)
                renderRadii(my.item, my.level + 1)
            elsif (my.isOval)
                my.radiusX = my.item.width/2
                my.radiusY = my.item.height/2
                if (my.radiusX < my.radiusY)
                    my.radius = my.radiusX
                else
                    my.radius = my.radiusY
                endif
>    $(my.indent)$(my.subIndent)topLeftRadius: $(my.radius)
>    $(my.indent)$(my.subIndent)topRightRadius: $(my.radius)
>    $(my.indent)$(my.subIndent)bottomRightRadius: $(my.radius)
>    $(my.indent)$(my.subIndent)bottomLeftRadius: $(my.radius)
            endif

            if (my.exportTopLeftPadding)
                renderTopAndLeftPadding("", my.item, my.level + 1)
            endif

            if (my.exportRightPadding)
                renderRightPadding("", my.item, my.level + 1, my.component)
            else
>    $(my.indent)$(my.subIndent)rightPadding: leftPadding
            endif
        
            if (my.exportBottomPadding)
                renderBottomPadding("", my.item, my.level + 1, my.component)
            else
>    $(my.indent)$(my.subIndent)bottomPadding: topPadding
            endif
        
            renderShapeFill(my.appOrLibrary, "", 0, my.item, my.level + 1, my.isInLibrary)
            renderShapeBorder(my.appOrLibrary, "", 0, my.item, my.level + 1, my.isInLibrary)
>    $(my.indent)}
        else
>
>    $(my.indent)// Sketch warning: layer $(my.itemName) is not a rectangle (or oval), property $(my.propertyName) can not be rendered
            echo "Sketch2QML warning: layer $(my.itemName) is not a rectangle (or oval), property $(my.propertyName) can not be rendered"
        endif
    endif
endfunction slider_renderComponentProperty_RectangleDataHandle


function slider_renderProgress(component, indent)
    my.subIndent = getIndent(my.indent)
    my.progress = slider_progress(my.component)?
    my.hasProgress = defined(my.progress)
    if (my.hasProgress)
        my.progressType = bestType(my.progress)
        my.progressIndent = getIndent(my.indent + 1)
        if (my.progressType = "symbol") #TODO: the rest of the types
>    $(my.subIndent)property alias override_defaultProgress: progressItem.override_defaultProgress
>    $(my.subIndent)property alias override_disabledProgress: progressItem.override_disabledProgress
>
>    $(my.subIndent)SketchSliderSymbolProgress {
>    $(my.progressIndent)id: progressItem
>    $(my.progressIndent)control: root
>    $(my.progressIndent)width: root.visualPosition * root.availableWidth
            #NB: symbols have an implicit size, we don't need to define it

            slider_renderComponentProperty_SymbolHandle(my.appOrLibrary, my.component, my.indent + 1, my.isInLibrary, "defaultProgress")
            slider_renderComponentProperty_SymbolHandle(my.appOrLibrary, my.component, my.indent + 1, my.isInLibrary, "disabledProgress")
>    $(my.subIndent)}
        else
>    $(my.subIndent)// WARNING Progress rendering for something that is not a "Symbol" is not implemented yet
        endif
    endif
endfunction slider_renderProgress


function renderComponent_Slider(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchSlider {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !slider_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "focusFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Background 
    my.background = slider_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground)
        my.backgroundType = bestType(my.background)
        if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground
>
>    background: SketchSliderSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: symbols have an implicit size, we don't need to define it

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")

            # Progress
            slider_renderProgress(my.component, 1)
>    }
        else
>    // WARNING Background rendering for something that is not a "Symbol" is not implemented yet
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif


    # Handle
    my.handle = slider_handle(my.component)?
    my.hasHandle = defined(my.handle)
    if (my.hasHandle)
        my.handleType = bestType(my.handle)

>
>    property alias defaultHandle: handleItem.defaultHandle
>    property alias focusedHandle: handleItem.focusedHandle
>    property alias pressedHandle: handleItem.pressedHandle
>    property alias hoveredHandle: handleItem.hoveredHandle
>    property alias disabledHandle: handleItem.disabledHandle
>
>    handle: Item {
>    $(my.subIndent)implicitWidth: 0
>    $(my.subIndent)implicitHeight: 0
>    $(my.subIndent)x: root.leftPadding + (root.horizontal ? root.visualPosition * (root.availableWidth - width) : (root.availableWidth - width) / 2)
>    $(my.subIndent)y: root.topPadding + (root.horizontal ? (root.availableHeight - height) / 2 : root.visualPosition * (root.availableHeight - height))
>
>    $(my.subIndent)SketchSliderMaterialHandle {
            my.handleSubIndent = getIndent(2)
>    $(my.handleSubIndent)id: handleItem
>    $(my.handleSubIndent)anchors.verticalCenter: parent.verticalCenter
>    $(my.handleSubIndent)control: root
>
            slider_renderHandleOffsetX(my.component, 2)
            
            #NB: rectangles don't have an implicit size, we need to define it
            renderItemImplicitSize(my.component, 2)

            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultHandle", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "focusedHandle", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedHandle", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredHandle", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledHandle", 1, 1, 1)
>    $(my.subIndent)}
>    }
    endif


    # Extra children
    for my.component.item where !slider_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}

endfunction renderComponent_Slider



############### Special case: Stack ###############


function renderComponent_Stack(appOrLibrary, component, isInLibrary)
    renderComponent_CustomParentType(my.appOrLibrary, my.component, my.isInLibrary, "StackLayout", 0)
endfunction renderComponent_Stack


############### Special case: Swipe ###############


function renderComponent_Swipe(appOrLibrary, component, isInLibrary)
    renderComponent_CustomParentType(my.appOrLibrary, my.component, my.isInLibrary, "SwipeView", 0)
endfunction renderComponentSwipe


############### Special case: TabBar ###############


function renderComponent_TabBar(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()

>
>SketchTabBar {
>    id: root
>
>    // Sketch warning: define a custom spacing in QML (e.g. spacing: 0)
>
    renderItemUserSetProperties(my.component, 0)

    #NB: We assume that instances defined inside a tabbar are tabbuttons
    for my.component.item
        if isSymbolInstance(item)
            generatePropertyAliasesForNonOverridableSymbolInstance(item, "", "")
        else
            generatePropertyAliases(item, "", "")
        endif
    endfor

    # All children
    for my.component.item
>
        if isSymbolInstance(item)
            renderNonOverridableSymbolInstance(my.appOrLibrary, item, 1, my.isInLibrary, "", 1, 0, 1) # No anchors
        else
            iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
        endif
    endfor
>}
endfunction renderComponent_TabBar


############### Special case: TabButton ###############


function tabbutton_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|(checked(Default|Hovered|Pressed|Disabled)))Background$", my.usedName) 
endfunction tabbutton_isExpectedLayer


function tabbutton_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|(checked(Default|Hovered|Pressed|Disabled)))Text$", my.usedName) 
endfunction tabbutton_isExpectedLayer


function tabbutton_isIconLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|(checked(Default|Hovered|Pressed|Disabled)))Icon$", my.usedName) 
endfunction tabbutton_isIconLayer


function tabbutton_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(focus|hover|press)Feedback$", my.usedName)
endfunction tabbutton_isFeedbackLayer


function tabbutton_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press)Feedback$", my.usedName)
endfunction tabbutton_isSpecialFeedback


function tabbutton_isExpectedLayer(name)
    return (tabbutton_isBackgroundLayer(my.name) | tabbutton_isTextLayer(my.name) | tabbutton_isIconLayer(my.name) | tabbutton_isFeedbackLayer(my.name))
endfunction tabbutton_isExpectedLayer


function tabbutton_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedDefault$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedPressed$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedHovered$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedDisabled$(my.suffix)")?
    endif

    return my.item
endfunction tabbutton_itemWithStates


function tabbutton_background(component)
    return tabbutton_itemWithStates(my.component, "Background")
endfunction tabbutton_background


function tabbutton_icon(component)
    return tabbutton_itemWithStates(my.component, "Icon")
endfunction tabbutton_icon


function tabbutton_text(component)
    return tabbutton_itemWithStates(my.component, "Text")
endfunction tabbutton_text


function tabbutton_isBackgroundOrFeedbackLayer(name)
    return (button_isBackgroundLayer(my.name) | button_isFeedbackLayer(my.name))
endfunction tabbutton_isBackgroundOrFeedbackLayer


function tabbutton_itemIsAboveBackgroundLayers(component, targetName)
    my.targetItemIndex = -1
    my.lastBackgroundOrContentIndex = -1
    for my.component.item where tabbutton_isBackgroundOrFeedbackLayer(name)
        my.currentIndex = index()
        if (string.lexcmp("$(name:camel)", my.targetName) = 0)
            my.targetItemIndex = my.currentIndex 
        elsif (my.currentIndex > my.lastBackgroundOrContentIndex)
            my.lastBackgroundOrContentIndex = my.currentIndex
        endif
    endfor

    return (my.targetItemIndex > my.lastBackgroundOrContentIndex)
endfunction tabbutton_itemIsAboveBackgroundLayers


function renderComponent_TabButton(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchTabButton {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !tabbutton_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "focusFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Focus feedback
    my.focusFeedbackIsAbove = tabbutton_itemIsAboveBackgroundLayers(my.component, "focusFeedback")
    if !renderComponent_Feedback(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusFeedback", "root.visualFocus", focusFeedbackZ(my.focusFeedbackIsAbove))
>
>    activeFocusOnTab: false
>
    endif

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = tabbutton_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background
    my.background = tabbutton_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif
>
>    property alias backgroundItem: backgroundItem

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>    background: SketchTabButtonSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to use it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
            
            elsif (my.backgroundType = "image")
>    background: SketchTabButtonImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
            
            elsif (my.backgroundType = "none")
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
>
            else
>    background: SketchTabButtonMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
            endif
>
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState || root.checkedHoveredState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState || root.checkedPressedState")
>    }
        elsif (my.hasBackground)
>
            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_hoveredBackground: backgroundItem.override_hoveredBackground
>    property alias override_pressedBackground: backgroundItem.override_pressedBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground

>    property alias override_checkedDefaultBackground: backgroundItem.override_checkedDefaultBackground
>    property alias override_checkedHoveredBackground: backgroundItem.override_checkedHoveredBackground
>    property alias override_checkedPressedBackground: backgroundItem.override_checkedPressedBackground
>    property alias override_checkedDisabledBackground: backgroundItem.override_checkedDisabledBackground
>
> 
>    background: SketchTabButtonSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: symbols have an implicit size, we don't need to define it

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground")
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")

>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground

>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>
>    background: SketchTabButtonImageBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: images have an implicit size, we don't need to define it
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)

>    }
            else
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground

>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>    property real backgroundRadius: (backgroundItem.partData ? backgroundItem.partData.radius : 0)
>    property real backgroundTopLeftRadius: (backgroundItem.partData ? backgroundItem.partData.topLeftRadius : 0)
>    property real backgroundTopRightRadius: (backgroundItem.partData ? backgroundItem.partData.topRightRadius : 0)
>    property real backgroundBottomRightRadius: (backgroundItem.partData ? backgroundItem.partData.bottomRightRadius : 0)
>    property real backgroundBottomLeftRadius: (backgroundItem.partData ? backgroundItem.partData.bottomLeftRadius : 0)
>
>
>    background: SketchTabButtonMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
            #NB: rectangles don't have an implicit size, we need to define it
            renderItemImplicitSize(my.component, 1)

            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
>    }
            endif
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif


    # Text and/or icon ?
    my.text = tabbutton_text(my.component)?
    my.hasText = defined(my.text)
    my.icon = tabbutton_icon(my.component)?
    my.hasIcon = defined(my.icon)
    my.hasTextAndIcon = my.hasText & my.hasIcon

     if (my.hasText | my.hasIcon)
        my.iconType = ""

        # Icon properties
        if (my.hasIcon)
            my.iconType = bestIconType(my.icon)

            if (my.iconType = "symbol")
>
>    property alias override_defaultIcon: iconItem.override_defaultIcon
>    property alias override_hoveredIcon: iconItem.override_hoveredIcon
>    property alias override_pressedIcon: iconItem.override_pressedIcon
>    property alias override_disabledIcon: iconItem.override_disabledIcon
>
>    property alias override_checkedDefaultIcon: iconItem.override_checkedDefaultIcon
>    property alias override_checkedHoveredIcon: iconItem.override_checkedHoveredIcon
>    property alias override_checkedPressedIcon: iconItem.override_checkedPressedIcon
>    property alias override_checkedDisabledIcon: iconItem.override_checkedDisabledIcon
            elsif (my.iconType = "text")
>
>    property alias iconItem: iconItem
>    property alias defaultIcon: iconItem.defaultText
>    property alias hoveredIcon: iconItem.hoveredText
>    property alias pressedIcon: iconItem.pressedText
>    property alias disabledIcon: iconItem.disabledText
>
>    property alias checkedDefaultIcon: iconItem.checkedDefaultText
>    property alias checkedHoveredIcon: iconItem.checkedHoveredText
>    property alias checkedPressedIcon: iconItem.checkedPressedText
>    property alias checkedDisabledIcon: iconItem.checkedDisabledText
            else
                # image
>
>    property alias defaultIcon: iconItem.defaultIcon
>    property alias hoveredIcon: iconItem.hoveredIcon
>    property alias pressedIcon: iconItem.pressedIcon
>    property alias disabledIcon: iconItem.disabledIcon
>
>    property alias checkedDefaultIcon: iconItem.checkedDefaultIcon
>    property alias checkedHoveredIcon: iconItem.checkedHoveredIcon
>    property alias checkedPressedIcon: iconItem.checkedPressedIcon
>    property alias checkedDisabledIcon: iconItem.checkedDisabledIcon
            endif
        endif


        # Text properties
        if (my.hasText)
>
>    property alias defaultText: textItem.defaultText
>    property alias hoveredText: textItem.hoveredText
>    property alias pressedText: textItem.pressedText
>    property alias disabledText: textItem.disabledText

>    property alias checkedDefaultText: textItem.checkedDefaultText
>    property alias checkedHoveredText: textItem.checkedHoveredText
>    property alias checkedPressedText: textItem.checkedPressedText
>    property alias checkedDisabledText: textItem.checkedDisabledText
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
            if (my.hasTextAndIcon)
                #  Text and icon: we don't use padding to define margins of contentItem
>    leftPadding: 0
>    rightPadding: 0
>    topPadding: 0
>    bottomPadding: 0
            else
                # Text only
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
            endif
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
        endif


        if (my.hasTextAndIcon)
            # Both text and icon
>
>    contentItem: Item {
>    $(my.subIndent)implicitWidth: textItem.implicitWidth
>    $(my.subIndent)implicitHeight: textItem.implicitHeight

            # Icon
            if (my.iconType = "symbol")
>
>    $(my.subIndent)SketchTabButtonVectorIcon {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0)

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0)
>    $(my.subIndent)}
            elsif (my.iconType = "text")
>
>    $(my.subIndent)SketchTabButtonText {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon",0, 0, 0, "defaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0, "hoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0, "pressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0, "disabledText")

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0, "checkedDefaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0, "checkedHoveredoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0, 0, 0, "checkedPressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0, "checkedDisabledText")
>    $(my.subIndent)}
            else
>
>    $(my.subIndent)SketchTabButtonIcon {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0)

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0)
>    $(my.subIndent)}
            endif


            # Text
>
>    $(my.subIndent)SketchTabButtonText {
>    $(my.subIndent)$(my.subIndent)id: textItem
>    $(my.subIndent)$(my.subIndent)control: root
>
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
>
>    $(my.subIndent)$(my.subIndent)leftPadding: (textData ? textData.leftPadding : 0)
>    $(my.subIndent)$(my.subIndent)rightPadding: (textData ? textData.rightPadding : 0)
>    $(my.subIndent)$(my.subIndent)topPadding: (textData ? textData.topPadding : 0)
>    $(my.subIndent)$(my.subIndent)bottomPadding: (textData ? textData.bottomPadding : 0)
>
>    $(my.subIndent)$(my.subIndent)font: root.font
>    $(my.subIndent)$(my.subIndent)text: root.text

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledText", 1, 1, 1)

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledText", 1, 1, 1)
>    $(my.subIndent)}
>    }
        elsif (my.hasIcon)
            # Icon only
            if (my.iconType = "symbol")
>
>    contentItem: SketchTabButtonVectorIcon {
>    $(my.subIndent)id: iconItem
>    $(my.subIndent)control: root
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIcon")

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIcon")
>    }
            elsif (my.iconType = "text")
>
>    contentItem: Item {
>    $(my.subIndent)implicitWidth: iconItem.implicitWidth
>    $(my.subIndent)implicitHeight: iconItem.implicitHeight
>
>    $(my.subIndent)SketchTabButtonText {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
>
>    $(my.subIndent)$(my.subIndent)$(my.subIndent)anchors.centerIn: parent
>
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon",0, 0, 0, "defaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0, "hoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0, "pressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0, "disabledText")

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0, "checkedDefaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0, "checkedHoveredoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0, 0, 0, "checkedPressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0, "checkedDisabledText")
>    $(my.subIndent)}
>    }
            else
>
>    contentItem: SketchTabButtonIcon {
>    $(my.subIndent)id: iconItem
>    $(my.subIndent)control: root

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIcon", 0, 0, 0)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0)
>    }
            endif
        else
            # Text only
>
>    contentItem: SketchTabButtonText {
>    $(my.subIndent)id: textItem
>    $(my.subIndent)control: root
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledText", 1, 1, 1)

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledText", 1, 1, 1)
>    }
        endif
    endif


    # Extra children
    for my.component.item where !tabbutton_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_TabButton


############### Special case: Textarea ###############


function textarea_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|focused|disabled)Background$", my.usedName) 
endfunction textarea_isBackgroundLayer


function textarea_background(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "focusedBackground")?
    endif
    return my.item
endfunction textarea_background


function textarea_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|focused|disabled)Text$", my.usedName) 
endfunction textarea_isTextLayer


function textarea_isOtherLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^errorMessage|(placeholder|selection(|Text)|(vertical|horizontal)Scrollbar)$", my.usedName) 
endfunction textarea_isOtherLayer


function textarea_isExpectedLayer(name)
    return (textarea_isTextLayer(my.name) | textarea_isBackgroundLayer(my.name) | textarea_isOtherLayer(my.name) | textarea_isFeedbackLayer(my.name))
endfunction textarea_isExpectedLayer


function textarea_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press|error)Feedback$", my.usedName)
endfunction textarea_isFeedbackLayer


function textarea_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press|error)Feedback$", my.usedName)
endfunction textarea_isSpecialFeedback


function textarea_determineType(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "focusedBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hoveredBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledBackground")?
    endif

    return bestType(my.item)
endfunction textarea_determineType


function renderComponent_Textarea(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importQtQuickTemplates()
    importExtraQmlModules()
>
>
    my.horizontalScrollbar = getChildNamed(my.component, "horizontalScrollbar")?
    my.verticalScrollbar = getChildNamed(my.component, "verticalScrollbar")?
    my.isScrollable = defined(my.horizontalScrollbar) | defined(my.verticalScrollbar)

    my.background = textarea_background(my.component)?
    my.hasBackground = defined(my.background)
    #NB: we dont' use bestType because background may ne undefined
    my.backgroundType = textarea_determineType(my.component)

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = textarea_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    my.controlId = "root"

    if (my.containsHoverOrPressFeedback | !my.hasBackground)
        # State layers and feedback layers OR no background

        if (my.isScrollable)
            my.controlId = "root.textArea"
>BaseSketchScrollableTextArea {
        else
>BaseSketchTextArea {
        endif
    else
        # State layers only

        if (my.backgroundType = "symbol")
            if (my.isScrollable)
>SketchSymbolScrollableTextArea {
            else
>SketchSymbolTextArea {
            endif
        elsif (my.backgroundType = "image")
            if (my.isScrollable)
>SketchImageScrollableTextArea {
            else
>SketchImageTextArea {
            endif
        else
            if (my.isScrollable)
>SketchMaterialScrollableTextArea {
            else
>SketchMaterialTextArea {
            endif
        endif
    endif

>    id: root

    if (my.isScrollable)
        renderItemImplicitSize(my.component, 0)
    else
        # Non scrollable textarea

        if (!my.containsHoverOrPressFeedback & (my.backgroundType = "material"))
            #NB: rectangles don't have an implicit size, we need to define it
            renderItemImplicitSize(my.component, 0)
        endif
        # Else: we can rely on the default implicit size (based on background and contentItem)
    endif

>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !textarea_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "errorFeedback")

    # Wrap mode
    if (my.isScrollable & !defined(my.horizontalScrollbar))
>    textArea.wrapMode: Text.Wrap
    endif

    # Scrollbars
    if defined(my.horizontalScrollbar)
        if isSymbolInstance(my.horizontalScrollbar)
>
>    property alias horizontalScrollbar: horizontalScrollbar
>    flickable.ScrollBar.horizontal: root.override_horizontalScrollbar
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.horizontalScrollbar, 1, my.isInLibrary, "property T.ScrollBar override_horizontalScrollbar: ", 1, 1, 0)
>    $(my.subIndent)policy: (root.contentWidth > root.width) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff 
>    }
        else
            echo "Sketch2Qml warning: TextArea $(my.component.name) contains a child named 'horizontalScrollbar' that is not a symbol instance"
        endif
    endif

    my.verticalScrollbar = getChildNamed(my.component, "verticalScrollbar")?
    if defined(my.verticalScrollbar)
        if isSymbolInstance(my.verticalScrollbar)
>
>    property alias verticalScrollbar: verticalScrollbar
>    flickable.ScrollBar.vertical: root.override_verticalScrollbar
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.verticalScrollbar, 1, my.isInLibrary, "property T.ScrollBar override_verticalScrollbar: ", 1, 1, 0)
>    $(my.subIndent)policy: (root.contentHeight > root.height) ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff 
>    }
        else
            echo "Sketch2Qml warning: TextArea $(my.component.name) contains a child named 'verticalScrollbar' that is not a symbol instance"
        endif
    endif


    # Background
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (!my.hasBackground)
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>
>    background: SketchTextAreaSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: $(my.controlId)
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            elsif (my.backgroundType = "image")
>
>    background: SketchTextAreaImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: $(my.controlId)
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
            else
>
>    background: SketchTextAreaMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: $(my.controlId)
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>
            endif

            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "$(my.controlId).hoveredState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "errorFeedback", "root.errorState")
>    }
        elsif (my.hasBackground)

            if (my.backgroundType = "symbol")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground")
            elsif (my.backgroundType = "image")
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground", 0, 0, 0)
            else
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground", 1, 1, 1)
            endif
        endif
    endif


    # Text
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledText", 1, 1, 1)

    # Placeholder
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "placeholder", 1, 1, 1)

    # Selection
    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selection", 0, 0, 0)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectionText", 0, 0, 0)

    # Error message 
    my.item = getChildNamed(my.component, "errorMessage")?
    if (defined(my.item))
        renderComponentInstance_Message(my.component, "errorMessage", 0, 0, 0)
>   
>    property bool onlyOpenErrorPopupInActiveFocus: false
>
>    onActiveFocusChanged: {
>        if (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus))
>            errorMessage.close();
>        else if (visible && errorState && root.Window.window) // We can not open a popup without a Window
>            errorMessage.open();
>    }
>
>    onErrorStateChanged: {
>        if (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus))
>            errorMessage.close();
>        else if (visible && root.Window.window) // We can not open a popup without a Window
>            errorMessage.open();
>    }
>
>    onVisibleChanged: {
>        if (!visible || (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus)))
>            errorMessage.close();
>        else if (errorState && root.Window.window) // We can not open a popup without a Window
>            errorMessage.open();
>    }
>
>    onWindowChanged: (window) => {
>        if (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus))
>            errorMessage.close();
>        else if (visible && errorState && window)
>            errorMessage.open();
>    }
    endif

    # Extra children
    for my.component.item where !textarea_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_Textarea



############### Special case: Textfield ###############


function textfield_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|focused|disabled|error)Background$", my.usedName) 
endfunction textfield_isBackgroundLayer


function textfield_background(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "focusedBackground")?
    endif
    return my.item
endfunction textfield_background


function textfield_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|focused|disabled|error)Text$", my.usedName) 
endfunction textfield_isTextLayer


function textfield_isOtherLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^errorMessage|(placeholder|selection(|Text))$", my.usedName) 
endfunction textfield_isOtherLayer


function textfield_isExpectedLayer(name)
    return (textfield_isTextLayer(my.name) | textfield_isBackgroundLayer(my.name) | textfield_isOtherLayer(my.name) | textfield_isFeedbackLayer(my.name))
endfunction textfield_isExpectedLayer


function textfield_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press|error)Feedback$", my.usedName)
endfunction textfield_isFeedbackLayer


function textfield_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press|error)Feedback$", my.usedName)
endfunction textfield_isSpecialFeedback


function textfield_determineType(component)
    my.item = getChildNamed(my.component, "defaultBackground")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "focusedBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hoveredBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabledBackground")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "errorBackground")?
    endif

    return bestType(my.item)
endfunction textfield_determineType


function renderComponent_Textfield(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>    
    my.background = textarea_background(my.component)?
    my.hasBackground = defined(my.background)
    #NB: we dont' use bestType because background may ne undefined
    my.backgroundType = textfield_determineType(my.component)

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = textfield_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    if (my.containsHoverOrPressFeedback)
        # State layers and feedback layers
>BaseSketchTextField {
    else
        # State layers only
        if (my.backgroundType = "symbol")
>SketchSymbolTextField {
        elsif (my.backgroundType = "image")
>SketchImageTextField {
        else
>SketchMaterialTextField {
        endif
    endif

>    id: root

    if (!my.containsHoverOrPressFeedback & (my.backgroundType = "material"))
        #NB: rectangles don't have an implicit size, we need to define it
        renderItemImplicitSize(my.component, 0)
    endif
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !textfield_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "errorFeedback")

    # Background
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (!my.hasBackground)
            my.backgroundType = "none"
        endif

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>
>    background: SketchTextFieldSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
            elsif (my.backgroundType = "image")
>
>    background: SketchTextFieldImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
            elsif (my.backgroundType = "none")
>
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
            else
>
>    background: SketchTextFieldMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
>
            endif
                renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState")
                renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "errorFeedback", "root.errorState")
>    }
        elsif (my.hasBackground)
            if (my.backgroundType = "symbol")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 0, my.isInLibrary, "errorBackground")
            elsif (my.backgroundType = "image")
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 0, my.isInLibrary, "errorBackground", 0, 0, 0)
            else
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "errorBackground", 1, 1, 1)
            endif
        endif
    endif

    # Text
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "defaultText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "hoveredText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "focusedText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "disabledText", 1, 1, 1)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "errorText", 1, 1, 1)

    # Placeholder
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "placeholder", 1, 1, 1)

    # Selection
    renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selection", 0, 0, 0)
    renderComponentProperty_TextData(my.appOrLibrary, my.component, 0, my.isInLibrary, "selectionText", 0, 0, 0)

    # Error message 
    my.item = getChildNamed(my.component, "errorMessage")?
    if (defined(my.item))
        renderComponentInstance_Message(my.component, "errorMessage", 0, 0, 0)
>
>    property bool onlyOpenErrorPopupInActiveFocus: false
>
>    onActiveFocusChanged: {
>        if (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus))
>            errorMessage.close();
>        else if (visible && errorState && root.Window.window) // We can not open a popup without a Window
>            errorMessage.open();
>    }
>
>    onErrorStateChanged: {
>        if (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus))
>            errorMessage.close();
>        else if (visible && root.Window.window) // We can not open a popup without a Window
>            errorMessage.open();
>    }
>
>    onVisibleChanged: {
>        if (!visible || (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus)))
>            errorMessage.close();
>        else if (errorState && root.Window.window) // We can not open a popup without a Window
>            errorMessage.open();
>    }
>
>    onWindowChanged: (window) => {
>        if (!errorState || (onlyOpenErrorPopupInActiveFocus && !activeFocus))
>            errorMessage.close();
>        else if (visible && errorState && window)
>            errorMessage.open();
>    }
    endif

    # Extra children
    for my.component.item where !textfield_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_Textfield



############### Special case: ToggleButton ###############


function togglebutton_isBackgroundLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|checked(Default|Hovered|Pressed|Disabled))Background$", my.usedName) 
endfunction togglebutton_isBackgroundLayer


function togglebutton_isTextLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|checked(Default|Hovered|Pressed|Disabled))Text$", my.usedName) 
endfunction togglebutton_isTextLayer


function togglebutton_isIconLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(default|hovered|pressed|disabled|checked(Default|Hovered|Pressed|Disabled))Icon$", my.usedName) 
endfunction togglebutton_isIconLayer


function togglebutton_isFeedbackLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(focus|hover|press)Feedback$", my.usedName)
endfunction togglebutton_isFeedbackLayer


function togglebutton_isSpecialFeedback(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^(hover|press)Feedback$", my.usedName)
endfunction togglebutton_isSpecialFeedback


function togglebutton_isOtherLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^menu$", my.usedName) 
endfunction togglebutton_isOtherLayer


function togglebutton_isExpectedLayer(name)
    return (togglebutton_isBackgroundLayer(my.name) | togglebutton_isTextLayer(my.name) | togglebutton_isIconLayer(my.name) | togglebutton_isFeedbackLayer(my.name) | togglebutton_isOtherLayer(my.name)) 
endfunction togglebutton_isExpectedLayer


function togglebutton_itemWithStates(component, suffix)
    my.item = getChildNamed(my.component, "default$(my.suffix)")?
    if !defined(my.item)
        my.item = getChildNamed(my.component, "pressed$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "hovered$(my.suffix)")?
    endif
    if !defined(my.item)
        my.item = getChildNamed(my.component, "disabled$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedDefault$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedPressed$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedHovered$(my.suffix)")?
    endif
     if !defined(my.item)
        my.item = getChildNamed(my.component, "checkedDisabled$(my.suffix)")?
    endif

    return my.item
endfunction togglebutton_itemWithStates


function togglebutton_background(component)
    return togglebutton_itemWithStates(my.component, "Background")
endfunction togglebutton_background


function togglebutton_icon(component)
    return togglebutton_itemWithStates(my.component, "Icon")
endfunction togglebutton_icon


function togglebutton_text(component)
    return togglebutton_itemWithStates(my.component, "Text")
endfunction togglebutton_text


function togglebutton_isBackgroundOrFeedbackLayer(name)
    return (togglebutton_isBackgroundLayer(my.name) | togglebutton_isFeedbackLayer(my.name)) 
endfunction togglebutton_isBackgroundOrFeedbackLayer


function togglebutton_itemIsAboveBackgroundLayers(component, targetName)
    my.targetItemIndex = -1
    my.lastBackgroundOrContentIndex = -1
    for my.component.item where togglebutton_isBackgroundOrFeedbackLayer(name)
        my.currentIndex = index()
        if (string.lexcmp("$(name:camel)", my.targetName) = 0)
            my.targetItemIndex = my.currentIndex 
        elsif (my.currentIndex > my.lastBackgroundOrContentIndex)
            my.lastBackgroundOrContentIndex = my.currentIndex
        endif
    endfor

    return (my.targetItemIndex > my.lastBackgroundOrContentIndex)
endfunction togglebutton_itemIsAboveBackgroundLayers


function renderComponent_ToggleButton(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importExtraQmlModules()
>
>
>SketchToggleButton {
>    id: root
>
    renderItemUserSetProperties(my.component, 0)
>
    # Aliases of extra children
    for my.component.item where !togglebutton_isExpectedLayer(name)
        generatePropertyAliases(item, "", "")
    endfor

    renderComponent_FeedbackAlias(my.component, 1, "focusFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "hoverFeedback")
    renderComponent_FeedbackAlias(my.component, 1, "pressFeedback")

    # Focus feedback
    my.focusFeedbackIsAbove = togglebutton_itemIsAboveBackgroundLayers(my.component, "focusFeedback")
    if !renderComponent_Feedback(my.appOrLibrary, my.component, 1, my.isInLibrary, "focusFeedback", "root.visualFocus", focusFeedbackZ(my.focusFeedbackIsAbove))
>
>    activeFocusOnTab: false
>
    endif

    my.containsHoverOrPressFeedback = 0
    for my.component.item
        my.containsHoverOrPressFeedback = togglebutton_isSpecialFeedback(name)
        if (my.containsHoverOrPressFeedback)
            last
        endif
    endfor

    # Background
    my.background = togglebutton_background(my.component)?
    my.hasBackground = defined(my.background)
    if (my.hasBackground | my.containsHoverOrPressFeedback)
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)
        else 
            my.backgroundType = "none"
        endif
>
>    property alias backgroundItem: backgroundItem

        if (my.containsHoverOrPressFeedback)
            if (my.backgroundType = "symbol")
>    background: SketchToggleButtonSymbolFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to use it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
            
            elsif (my.backgroundType = "image")
>    background: SketchToggleButtonImageFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
            
            elsif (my.backgroundType = "none")
>    background: Item {
>    $(my.subIndent)id: backgroundItem
                #NB: we need to define an implicit size
                renderItemImplicitSize(my.component, 1)
>
            else
>    background: SketchToggleButtonMaterialFeedbackBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
            endif
>
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoverFeedback", "root.hoveredState || root.checkedHoveredState")
            renderComponent_Feedback(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressFeedback", "root.pressedState || root.checkedPressedState")
>    }
        elsif (my.hasBackground)
>
            if (my.backgroundType = "symbol")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>    property alias override_defaultBackground: backgroundItem.override_defaultBackground
>    property alias override_hoveredBackground: backgroundItem.override_hoveredBackground
>    property alias override_pressedBackground: backgroundItem.override_pressedBackground
>    property alias override_disabledBackground: backgroundItem.override_disabledBackground
>    property alias override_checkedDefaultBackground: backgroundItem.override_checkedDefaultBackground
>    property alias override_checkedHoveredBackground: backgroundItem.override_checkedHoveredBackground
>    property alias override_checkedPressedBackground: backgroundItem.override_checkedPressedBackground
>    property alias override_checkedDisabledBackground: backgroundItem.override_checkedDisabledBackground
>
>    flat: (override_defaultBackground === null)
> 
>    background: SketchToggleButtonSymbolBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground")
>    }
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>    flat: (defaultBackground === null) || (defaultBackground.source === "")
>
>    background: SketchToggleButtonImageBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
>    }
            else
>    property alias defaultBackground: backgroundItem.defaultBackground
>    property alias hoveredBackground: backgroundItem.hoveredBackground
>    property alias pressedBackground: backgroundItem.pressedBackground
>    property alias disabledBackground: backgroundItem.disabledBackground
>    property alias checkedDefaultBackground: backgroundItem.checkedDefaultBackground
>    property alias checkedHoveredBackground: backgroundItem.checkedHoveredBackground
>    property alias checkedPressedBackground: backgroundItem.checkedPressedBackground
>    property alias checkedDisabledBackground: backgroundItem.checkedDisabledBackground
>
>    property real backgroundRadius: (backgroundItem.partData ? backgroundItem.partData.radius : 0)
>    property real backgroundTopLeftRadius: (backgroundItem.partData ? backgroundItem.partData.topLeftRadius : 0)
>    property real backgroundTopRightRadius: (backgroundItem.partData ? backgroundItem.partData.topRightRadius : 0)
>    property real backgroundBottomRightRadius: (backgroundItem.partData ? backgroundItem.partData.bottomRightRadius : 0)
>    property real backgroundBottomLeftRadius: (backgroundItem.partData ? backgroundItem.partData.bottomLeftRadius : 0)
>
>    flat: (defaultBackground === null)
>
>    background: SketchToggleButtonMaterialBackground {
>    $(my.subIndent)id: backgroundItem
>    $(my.subIndent)control: root
                 #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedBackground", 1, 1, 1)
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledBackground", 1, 1, 1)
>    }
            endif
        endif
    else
        # No background, we need to define our implicit height (text may be vertically centered)
        renderItemImplicitHeight(my.component, 0)
    endif


    # Text and/or icon ?
    my.text = togglebutton_text(my.component)?
    my.hasText = defined(my.text)
    my.icon = togglebutton_icon(my.component)?
    my.hasIcon = defined(my.icon)
    my.hasTextAndIcon = my.hasText & my.hasIcon

 
     if (my.hasText | my.hasIcon)
        my.iconType = ""

        # Icon properties
        if (my.hasIcon)
            my.iconType = bestIconType(my.icon)

            if (my.iconType = "symbol")
>
>    property alias override_defaultIcon: iconItem.override_defaultIcon
>    property alias override_hoveredIcon: iconItem.override_hoveredIcon
>    property alias override_pressedIcon: iconItem.override_pressedIcon
>    property alias override_disabledIcon: iconItem.override_disabledIcon
>
>    property alias override_checkedDefaultIcon: iconItem.override_checkedDefaultIcon
>    property alias override_checkedHoveredIcon: iconItem.override_checkedHoveredIcon
>    property alias override_checkedPressedIcon: iconItem.override_checkedPressedIcon
>    property alias override_checkedDisabledIcon: iconItem.override_checkedDisabledIcon
            elsif (my.iconType = "text")
>
>    property alias iconItem: iconItem
>    property alias defaultIcon: iconItem.defaultText
>    property alias hoveredIcon: iconItem.hoveredText
>    property alias pressedIcon: iconItem.pressedText
>    property alias disabledIcon: iconItem.disabledText
>
>    property alias checkedDefaultIcon: iconItem.checkedDefaultText
>    property alias checkedHoveredIcon: iconItem.checkedHoveredText
>    property alias checkedPressedIcon: iconItem.checkedPressedText
>    property alias checkedDisabledIcon: iconItem.checkedDisabledText
            else
                # image
>
>    property alias defaultIcon: iconItem.defaultIcon
>    property alias hoveredIcon: iconItem.hoveredIcon
>    property alias pressedIcon: iconItem.pressedIcon
>    property alias disabledIcon: iconItem.disabledIcon
>
>    property alias checkedDefaultIcon: iconItem.checkedDefaultIcon
>    property alias checkedHoveredIcon: iconItem.checkedHoveredIcon
>    property alias checkedPressedIcon: iconItem.checkedPressedIcon
>    property alias checkedDisabledIcon: iconItem.checkedDisabledIcon
            endif
        endif


        # Text properties
        if (my.hasText)
>
>    property alias defaultText: textItem.defaultText
>    property alias hoveredText: textItem.hoveredText
>    property alias pressedText: textItem.pressedText
>    property alias disabledText: textItem.disabledText

>    property alias checkedDefaultText: textItem.checkedDefaultText
>    property alias checkedHoveredText: textItem.checkedHoveredText
>    property alias checkedPressedText: textItem.checkedPressedText
>    property alias checkedDisabledText: textItem.checkedDisabledText
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
            if (my.hasTextAndIcon)
                #  Text and icon: we don't use padding to define margins of contentItem
>    leftPadding: 0
>    rightPadding: 0
>    topPadding: 0
>    bottomPadding: 0
            else
                # Text only
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
            endif
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
        endif


        if (my.hasTextAndIcon)
            # Both text and icon
>
>    contentItem: Item {
>    $(my.subIndent)implicitWidth: textItem.implicitWidth
>    $(my.subIndent)implicitHeight: textItem.implicitHeight

            # Icon
            if (my.iconType = "symbol")
>
>    $(my.subIndent)SketchToggleButtonVectorIcon {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0)

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0)
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0)
>    $(my.subIndent)}
            elsif (my.iconType = "text")
>
>    $(my.subIndent)SketchToggleButtonText {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon",0, 0, 0, "defaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0, "hoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0, "pressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0, "disabledText")

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0, "checkedDefaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0, "checkedHoveredoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0, 0, 0, "checkedPressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0, "checkedDisabledText")
>    $(my.subIndent)}
            else
>
>    $(my.subIndent)SketchToggleButtonIcon {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
                renderItemPositioning(my.icon, 1, 1, 1)

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0)

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0, 0, 0)
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0)
>    $(my.subIndent)}
            endif


            # Text
>
>    $(my.subIndent)SketchToggleButtonText {
>    $(my.subIndent)$(my.subIndent)id: textItem
>    $(my.subIndent)$(my.subIndent)control: root
>
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
>
>    $(my.subIndent)$(my.subIndent)leftPadding: (textData ? textData.leftPadding : 0)
>    $(my.subIndent)$(my.subIndent)rightPadding: (textData ? textData.rightPadding : 0)
>    $(my.subIndent)$(my.subIndent)topPadding: (textData ? textData.topPadding : 0)
>    $(my.subIndent)$(my.subIndent)bottomPadding: (textData ? textData.bottomPadding : 0)
>
>    $(my.subIndent)$(my.subIndent)font: root.font
>    $(my.subIndent)$(my.subIndent)text: root.text

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledText", 1, 1, 1)

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledText", 1, 1, 1)
>    $(my.subIndent)}
>    }
        elsif (my.hasIcon)
            # Icon only
            if (my.iconType = "symbol")
>
>    contentItem: SketchToggleButtonVectorIcon {
>    $(my.subIndent)id: iconItem
>    $(my.subIndent)control: root
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIcon")

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIcon")
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIcon")
>    }
            elsif (my.iconType = "text")
>
>    contentItem: Item {
>    $(my.subIndent)implicitWidth: iconItem.implicitWidth
>    $(my.subIndent)implicitHeight: iconItem.implicitHeight
>
>    $(my.subIndent)SketchToggleButtonText {
>    $(my.subIndent)$(my.subIndent)id: iconItem
>    $(my.subIndent)$(my.subIndent)control: root
>
>    $(my.subIndent)$(my.subIndent)$(my.subIndent)anchors.centerIn: parent
>
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultIcon",0, 0, 0, "defaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "hoveredIcon", 0, 0, 0, "hoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "pressedIcon", 0, 0, 0, "pressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "disabledIcon", 0, 0, 0, "disabledText")

                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0, "checkedDefaultText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0, "checkedHoveredoveredText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedPressedIcon", 0, 0, 0, "checkedPressedText")
                renderComponentProperty_TextData(my.appOrLibrary, my.component, 2, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0, "checkedDisabledText")
>    $(my.subIndent)}
>    }
            else
>
>    contentItem: SketchToggleButtonIcon {
>    $(my.subIndent)id: iconItem
>    $(my.subIndent)control: root

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledIcon", 0, 0, 0)

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedIcon", 0, 0, 0)
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledIcon", 0, 0, 0)
>    }
            endif
        else
            # Text only
>
>    contentItem: SketchToggleButtonText {
>    $(my.subIndent)id: textItem
>    $(my.subIndent)control: root
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "hoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "pressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "disabledText", 1, 1, 1)

            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDefaultText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedHoveredText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedPressedText", 1, 1, 1)
            renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "checkedDisabledText", 1, 1, 1)
>    }
        endif
    endif



    # Menu
    my.menu = getChildNamed(my.component, "menu")?
    if defined(my.menu)
        if isSymbolInstance(my.menu)
>
>    property alias menu: menu
            renderNonOverridableSymbolInstance(my.appOrLibrary, my.menu, 1, my.isInLibrary, "", 0, 1, 1)
>
>    onToggled: {
>        if (menu.opened)
>            menu.close();
>        else
>            menu.open();
>    }
>
>    onVisibleChanged: {
>        if (!visible)
>            menu.close();
>    }
>
>    Connections {
>        target: menu
>        function onClosed() {
>            root.checked = false;
>        }
>    }
>
        else
            echo "Sketch2Qml warning: ToggleButton $(my.component.name) contains a child named 'menu' that is not a symbol instance"
        endif
    endif


    # Extra children
    for my.component.item where !togglebutton_isExpectedLayer(name)
>    
        if first ()
>    //
>    // Sketch warning: extra children
>    //
        endif
        iterateOnItem(my.appOrLibrary, item, 1, my.isInLibrary, "")
    endfor
>}
endfunction renderComponent_ToggleButton


############### Special case: ToolTip ###############


function tooltip_isExpectedLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^default(Background|Text)$", my.usedName)
endfunction tooltip_isExpectedLayer


function renderComponent_ToolTip(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importQtQuickTemplates()
    importExtraQmlModules()
>
>
>T.ToolTip {
>    id: root
>
>    implicitWidth: Math.max(implicitBackgroundWidth + leftInset + rightInset, contentWidth + leftPadding + rightPadding)
>    implicitHeight: Math.max(implicitBackgroundHeight + topInset + bottomInset, contentHeight + topPadding + bottomPadding)
>
>    closePolicy: T.Popup.CloseOnEscape | T.Popup.CloseOnPressOutsideParent | T.Popup.CloseOnReleaseOutsideParent
     # Default value of QtQuick.Controls.Basic.ToolTip
>    margins: 6
>
    renderItemUserSetProperties(my.component, 0)
>
>

    # Aliases of extra children
    my.hasExtraChildren = 0
    for my.component.item where !tooltip_isExpectedLayer(name)
        my.hasExtraChildren = 1
        generatePropertyAliases(item, "", "")
    endfor


    # Background (and extra children)
    my.background = getChildNamed(my.component, "defaultBackground")?
    my.hasBackground = defined(my.background)

    if (my.hasExtraChildren)
        # We must create an item to display our background and extra children
        # Otherwise, extra children will be parented in our contentItem and will inherit its margins

        # Background properties (if needed)
        my.backgroundType = ""
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)

            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: tooltipBackground.contentItem
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: tooltipBackground.partData
            else
>    property alias defaultBackground: tooltipBackground.partData
            endif
        endif

>    background: Item {
        # Background
        if (my.hasBackground)
>    $(my.subIndent)implicitWidth: tooltipBackground.implicitWidth
>    $(my.subIndent)implicitHeight: tooltipBackground.implicitHeight
>
            if (my.backgroundType = "symbol")
>    $(my.subIndent)SketchControlSymbolPart {
>    $(my.subIndent)$(my.subIndent)id: tooltipBackground
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
                #NB: symbols have an implicit size, we don't need to define it

                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultBackground", 1, "contentItem")
            elsif (my.backgroundType = "image")
>    $(my.subIndent)SketchControlImagePart {
>    $(my.subIndent)$(my.subIndent)id: tooltipBackground
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
                 #NB: images have an implicit size, we don't need to define it

                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
            else
>    $(my.subIndent)SketchControlMaterialPart {
>    $(my.subIndent)$(my.subIndent)id: tooltipBackground
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent

                #NB: rectangles don't have an implicit size, we need to define it
                renderItemImplicitSize(my.component, 1)

                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
            endif
>    $(my.subIndent)}
        else
            # No background
            renderItemImplicitSize(my.component, 1)
        endif

        # Extra children
        for my.component.item where !tooltip_isExpectedLayer(name)
>    
            if first ()
>    $(my.subIndent)//
>    $(my.subIndent)// Sketch warning: extra children
>    $(my.subIndent)//
            endif
            iterateOnItem(my.appOrLibrary, item, 2, my.isInLibrary, "")
        endfor
>    }  

    elsif (my.hasBackground)
        my.backgroundType = bestType(my.background)

        if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: tooltipBackground.contentItem
>    background: SketchControlSymbolPart {
>    $(my.subIndent)id: tooltipBackground
            #NB: symbols have an implicit size, we don't need to define it

            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, "contentItem")
>    }
        elsif (my.backgroundType = "image")
>    property alias defaultBackground: tooltipBackground.partData
>    background: SketchControlImagePart {
>    $(my.subIndent)id: tooltipBackground
            #NB: images have an implicit size, we don't need to define it

            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        else
>    property alias defaultBackground: tooltipBackground.partData
>    background: SketchControlMaterialPart {
>    $(my.subIndent)id: tooltipBackground
            #NB: rectangles don't have an implicit size, we need to define it
            renderItemImplicitSize(my.component, 1)

            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        endif
    else
        # No background
    endif


    # Text
>    property alias defaultText: textItem.textData
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
>
>    contentItem: SketchControlTextPart {
>    $(my.subIndent)id: textItem
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1, "textData")
>    }
>}
endfunction renderComponent_ToolTip


############### Special case: Message ###############

function message_isExpectedLayer(name)
    my.usedName = "$(my.name:camel)"
    return regexp.match("(?i)^default(Background|Text)$", my.usedName)
endfunction message_isExpectedLayer


function renderComponent_Message(appOrLibrary, component, isInLibrary)
    my.subIndent = getIndent(1)

    importCommonQmlModules()
    importQtQuickTemplates()
    importExtraQmlModules()
>
>
    # We use T.ToolTip instead of T.Popup to keep it inside our window
    # and to flip it horizontally and/or vertically when needed
>T.ToolTip {
>    id: root
>
>    implicitWidth: Math.max(implicitBackgroundWidth + leftInset + rightInset, contentWidth + leftPadding + rightPadding)
>    implicitHeight: Math.max(implicitBackgroundHeight + topInset + bottomInset, contentHeight + topPadding + bottomPadding)
>
>    closePolicy: T.Popup.NoAutoClose
    # Default value of QtQuick.Controls.Basic.ToolTip
>    margins: 6
>
    renderItemUserSetProperties(my.component, 0)
>
>

    # Aliases of extra children
    my.hasExtraChildren = 0
    for my.component.item where !message_isExpectedLayer(name)
        my.hasExtraChildren = 1
        generatePropertyAliases(item, "", "")
    endfor


    # Background (and extra children)
    my.background = getChildNamed(my.component, "defaultBackground")?
    my.hasBackground = defined(my.background)

    if (my.hasExtraChildren)
        # We must create an item to display our background and extra children
        # Otherwise, extra children will be parented in our contentItem and will inherit its margins

        # Background properties (if needed)
        my.backgroundType = ""
        if (my.hasBackground)
            my.backgroundType = bestType(my.background)

            if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: messageBackground.contentItem
            elsif (my.backgroundType = "image")
>    property alias defaultBackground: messageBackground.partData
            else
>    property alias defaultBackground: messageBackground.partData
            endif
        endif

>    background: Item {
        # Background
        if (my.hasBackground)
>    $(my.subIndent)implicitWidth: messageBackground.implicitWidth
>    $(my.subIndent)implicitHeight: messageBackground.implicitHeight
>
            if (my.backgroundType = "symbol")
>    $(my.subIndent)SketchControlSymbolPart {
>    $(my.subIndent)$(my.subIndent)id: messageBackground
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
                renderComponentProperty_Symbol(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultBackground", 1, "contentItem")
            elsif (my.backgroundType = "image")
>    $(my.subIndent)SketchControlImagePart {
>    $(my.subIndent)$(my.subIndent)id: messageBackground
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
                renderComponentProperty_ImageData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
            else
>    $(my.subIndent)SketchControlMaterialPart {
>    $(my.subIndent)$(my.subIndent)id: messageBackground
>    $(my.subIndent)$(my.subIndent)anchors.fill: parent
                renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 2, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
            endif
>    $(my.subIndent)}
        else
            # No background
            # => We assume that it is important to define our implicitHeight in case our contentItem is empty
            renderItemImplicitHeight(my.component, 1)
        endif

        # Extra children
        for my.component.item where !message_isExpectedLayer(name)
>    
            if first ()
>    $(my.subIndent)//
>    $(my.subIndent)// Sketch warning: extra children
>    $(my.subIndent)//
            endif
            iterateOnItem(my.appOrLibrary, item, 2, my.isInLibrary, "")
        endfor
>    }  

    elsif (my.hasBackground)
        my.backgroundType = bestType(my.background)

        if (my.backgroundType = "symbol")
>    property alias override_defaultBackground: messageBackground.contentItem
>    background: SketchControlSymbolPart {
>    $(my.subIndent)id: messageBackground
            renderComponentProperty_Symbol(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, "contentItem")
>    }
        elsif (my.backgroundType = "image")
>    property alias defaultBackground: messageBackground.partData
>    background: SketchControlImagePart {
>    $(my.subIndent)id: messageBackground
            renderComponentProperty_ImageData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        else
>    property alias defaultBackground: messageBackground.partData
>    background: SketchControlMaterialPart {
>    $(my.subIndent)id: messageBackground
            # => We assume that it is important to define our implicitHeight in case our contentItem is empty
            renderItemImplicitHeight(my.component, 1)
            renderComponentProperty_RectangleData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultBackground", 1, 1, 1, "partData")
>    }
        endif
    endif
    

    # Text
>    property alias defaultText: textItem.textData
>
>    property alias wrapMode: textItem.wrapMode
>    property alias elide: textItem.elide
>    property alias horizontalAlignment: textItem.horizontalAlignment
>    property alias verticalAlignment: textItem.verticalAlignment
>
>    leftPadding: (textItem.textData ? textItem.textData.leftPadding : 0)
>    rightPadding: (textItem.textData ? textItem.textData.rightPadding : 0)
>    topPadding: (textItem.textData ? textItem.textData.topPadding : 0)
>    bottomPadding: (textItem.textData ? textItem.textData.bottomPadding : 0)
>
>    text: textItem.textData ? textItem.textData.text : ""
>    font: textItem.textData ? textItem.textData.font : Qt.application.font
>
>    contentItem: SketchControlTextPart {
>    $(my.subIndent)id: textItem
>
>    $(my.subIndent)font: root.font
>    $(my.subIndent)text: root.text
        renderComponentProperty_TextData(my.appOrLibrary, my.component, 1, my.isInLibrary, "defaultText", 1, 1, 1, "textData")
>    }
>}
endfunction renderComponent_Message


############### Generic cases ###############


function renderComponent_CustomParentType(appOrLibrary, component, isInLibrary, parentType, canHaveBackground)
    importCommonQmlModules()
>
>  
>$(my.parentType:Pascal) {
>    id: root
    #NB: custom item - we need an implicit size
    renderItemImplicitSize(my.component, 0)
>
    renderComponentProperties(my.component)

    # Background
    if (my.canHaveBackground & defined(my.component.hasBackground) & my.component.hasBackground)
>    
>    Rectangle {
>        anchors.fill: parent
        renderColorProperty(my.appOrLibrary, "color", my.component.backgroundColor, 1)
>    }
>
    endif
 
    # Content
    renderItemChildren(my.appOrLibrary, my.component, 0, my.isInLibrary)    
>}
endfunction renderComponent_CustomParentType


function renderComponent_Default(appOrLibrary, component, isInLibrary)
    importCommonQmlModules()
>
>  
    if (defined(my.component.hasBackground) & my.component.hasBackground)
>Rectangle {
    else    
>Item { 
    endif
>    id: root
    #NB: custom item - we need an implicit size
    renderItemImplicitSize(my.component, 0)
>
    if (defined(my.component.hasBackground) & my.component.hasBackground)
        renderColorProperty(my.appOrLibrary, "color", my.component.backgroundColor, 0)
>        
    endif

    renderComponentProperties(my.component)
    renderItemChildren(my.appOrLibrary, my.component, 0, my.isInLibrary)
>}
endfunction renderComponent_Default


function renderComponent(appOrLibrary, component, isInLibrary)
    global.sketch2qml_currentComponent = my.component

    if (defined (my.component.parentType) & (string.length(my.component.parentType) > 0))
        # To ease the definition of widgets, we are case insensitive
        #TODO: add extra widgets
        my.parentType = "$(my.component.parentType:lower)"
        if (my.parentType = "button")
            renderComponent_Button(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "buttongroup")
            renderComponent_ButtonGroup(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "checkbox")
            renderComponent_CheckBox(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "combobox")
            renderComponent_Combobox(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "comboboxitem")
            renderComponent_ComboboxItem(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "list")
            renderComponent_List(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "menu")
            renderComponent_Menu(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "menuitem")
            renderComponent_MenuItem(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "message")
            renderComponent_Message(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "popup")
            renderComponent_Popup(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "radiobutton")
            renderComponent_RadioButton(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "scrollbar")
            renderComponent_Scrollbar(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "scrollview")
            renderComponent_Scrollview(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "slider")
            renderComponent_Slider(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "stack")
            renderComponent_Stack(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "swipe")
            renderComponent_Swipe(my.appOrLibrary, my.component, my.isInLibrary)
        elsif( my.parentType = "tabbar")
            renderComponent_TabBar(my.appOrLibrary, my.component, my.isInLibrary)
        elsif( my.parentType = "tabbutton")
            renderComponent_TabButton(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "textarea")
            renderComponent_Textarea(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "textfield")
            renderComponent_Textfield(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "togglebutton")
            renderComponent_ToggleButton(my.appOrLibrary, my.component, my.isInLibrary)
        elsif (my.parentType = "tooltip")
            renderComponent_ToolTip(my.appOrLibrary, my.component, my.isInLibrary)
        else
            # Custom type
            renderComponent_CustomParentType(my.appOrLibrary, my.component, my.isInLibrary, my.component.parentType, 1)
        endif
    else
        renderComponent_Default(my.appOrLibrary, my.component, my.isInLibrary)
    endif
endfunction renderComponent


#############################################################################
# Functions to render screens (i.e. artboards)
#
function renderChildrenAsAliases(component, level)
    my.indent = getIndent(my.level)
    
    for my.component.item
>    $(my.indent)property alias $(item.name:camel): $(item.name:camel)
        renderChildrenAsAliases(item, my.level)
    endfor
endfunction renderChildrenAsAliases


function renderScreen(appOrLibrary, screen, isInLibrary)
    # Import QML modules
    importCommonQmlModules()
>
    importLibraryQmlModule()
>    
    importSpecificQmlModules(my.appOrLibrary)
>
>  
    if defined (my.screen.parentType)
        my.isCustomType = 1
>$(my.screen.parentType:Pascal) {
    else
        my.isCustomType = 0
        if (defined(my.screen.hasBackground) & my.screen.hasBackground)
>Rectangle {    
        else
>Item { 
        endif
    endif
>    id: root
    renderItemImplicitSize(my.screen, 0)

    if (defined(my.screen.hasBackground) & my.screen.hasBackground)
>   
        if (my.isCustomType)
>    Rectangle {
>        anchors.fill: parent
        renderColorProperty(my.appOrLibrary, "color", my.screen.backgroundColor, 1)
>    }
        else
            renderColorProperty(my.appOrLibrary, "color", my.screen.backgroundColor, 0)
        endif
>
    endif

    # Custom properties        
    renderItemUserSetProperties(my.screen, 0) 
>
    # Aliases
    renderChildrenAsAliases(my.screen, 0)
>
    # Content
    renderItemChildren(my.appOrLibrary, my.screen, 0, my.isInLibrary)
>}
endfunction renderScreen


function renderScreenInWindow(appOrLibrary, screen, isInLibrary)
    # Import QML modules
    importCommonQmlModules()
>
    importLibraryQmlModule()
>    
    importSpecificQmlModules(my.appOrLibrary)
>
>
>Window {
>    id: root
>
>    width: $(my.screen.width)
>    height: $(my.screen.height)
>    visible: true
>    color: "white"
    renderStringProperty("title", my.screen.name, 0)
>
>    // To enable hot reload
>    Loader {
>        anchors.fill: parent
>        source: (QmlHotReloader.url != "")
>                ? "qrc:/qml/$(global.sketch2qml_appOrLibrarySubPath)/$(screen.name: pascal).qml"
>                : ""
>    }
>}
endfunction renderScreenInWindow



#############################################################################
# QML properties aliases per type
#

function generatePropertyAliasesForShape(item, alias, path)
    if useSharedStyle(my.item)
        my.alias = my.alias + my.item.name
        my.path = my.path + "$(my.item.name:camel)"
>    property alias $(my.alias: camel): $(my.path: camel)
    endif

    for my.item.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction generatePropertyAliasesForShape


function generatePropertyAliasesForImage(item, alias, path)
    my.alias = my.alias + my.item.name
    my.path = my.path + "$(my.item.name:camel)"
>    property alias $(my.alias: camel): $(my.path: camel)

    for my.item.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction generatePropertyAliasesForImage


function generatePropertyAliasesForText(item, alias, path)
    my.alias = my.alias + my.item.name
    my.path = my.path + "$(my.item.name:camel)"
>    property alias $(my.alias: camel): $(my.path: camel)

    for my.item.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction generatePropertyAliasesForText


function generatePropertyAliasesForStates(item, alias, path)
    #the States node will not appear per se : we iterate directly from parent
    for my.item.item
        generatePropertyAliases(item, my.alias, my.path)
    endfor
endfunction generatePropertyAliasesForStates


function generatePropertyAliasesForNonOverridableSymbolInstance(item, alias, path)
    my.alias = my.alias + my.item.name
    my.path = my.path + "$(my.item.name:camel)"
>    property alias $(my.alias: camel): $(my.path: camel)

    for my.item.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction generatePropertyAliasesForNonOverridableSymbolInstance


function generatePropertyAliasesForSymbolInstance(item, alias, path)
    my.alias = my.alias + my.item.name
    my.path = my.path + "$(my.item.name:camel)"
>    property alias $(my.alias: camel): $(my.path: camel)
    if currentComponentHasSymbolOverrideForItem(my.item)
>    property alias override_$(my.alias: camel): overridable_$(my.path: camel).contentItem
    endif

    for my.item.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction generatePropertyAliasesForSymbolInstance


function generatePropertyAliasesForDefault(item, alias, path)
    my.alias = my.alias + my.item.name
    my.path = my.path + "$(my.item.name:camel)"
>    property alias $(my.alias: camel): $(my.path: camel)

    for my.item.item
        generatePropertyAliases(item, "", "")
    endfor
endfunction generatePropertyAliasesForDefault


#############################################################################
# Main iteration function for QML aliases
#
function generatePropertyAliases(item, alias, path)
#TODO: check for each type if it is rendered with an export image, and switch type accordingly
    if defined(my.item.type)
        if (isRectangle(my.item) | isOval(my.item) | isLine(my.item))
            generatePropertyAliasesForShape(my.item, my.alias, my.path)
        elsif (isText(my.item))
            generatePropertyAliasesForText(my.item, my.alias, my.path)
        elsif (isImage(my.item))
            generatePropertyAliasesForImage(my.item, my.alias, my.path)
        elsif (my.item.type = "States")
            generatePropertyAliasesForStates(my.item, my.alias, my.path)
        else #default aliases for other types
            if isSymbolInstance(my.item)
                generatePropertyAliasesForSymbolInstance(my.item, my.alias, my.path)
            else
                generatePropertyAliasesForDefault(my.item, my.alias, my.path)
            endif
        endif
    endif
endfunction generatePropertyAliases


.endtemplate
